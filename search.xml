<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git</title>
      <link href="/2020/03/31/git/"/>
      <url>/2020/03/31/git/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>可以毫不夸张的来说，Git 是每个开发必备的一个技能，在团队协作开发当中，Git 的存在犹如黑暗当中的一道光照亮着我们。设想一下，如果你在一个团队开发当中，还是使用传统的 FTP 上传模式，你会多疯狂？其实很想写一段很长的话来表达，传统模式和 Git 的对比，不过一想意义不大！Git 作为当前时代下最强大的版本控制系统，强大肯定有它独特的地方！PS：个人看法，当然肯定有同僚喜爱别的工具，各有各的看法嘛！</p><h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h4><p>自 2002 年开始，<a href="https://zh.wikipedia.org/wiki/林纳斯·托瓦兹" target="_blank" rel="noopener">林纳斯·托瓦兹</a> 决定使用 <a href="https://zh.wikipedia.org/wiki/BitKeeper" target="_blank" rel="noopener">BitKeeper</a> 作为 <a href="https://zh.wikipedia.org/wiki/Linux內核" target="_blank" rel="noopener">Linux内核</a> 主要的版本控制系统用以维护代码。因为 BitKeeper 为商业软件（BitMover 公司免费授权给 Linux 社区使用），这个决定在社区中长期遭受质疑。在 Linux 社区中，特别是 <a href="https://zh.wikipedia.org/wiki/理查德·斯托曼" target="_blank" rel="noopener">理查德·斯托曼</a> 与 <a href="https://zh.wikipedia.org/wiki/自由軟體基金會" target="_blank" rel="noopener">自由软件基金会</a> 的成员，主张应该使用开放源代码的软件来作为 Linux 内核的版本控制系统。<a href="https://zh.wikipedia.org/wiki/林纳斯·托瓦兹" target="_blank" rel="noopener">林纳斯·托瓦兹</a> 曾考虑过采用现成软件作为版本控制系统（例如<a href="https://zh.wikipedia.org/wiki/Monotone" target="_blank" rel="noopener">Monotone</a>），但这些软件都存在一些问题，特别是性能不佳。现成的方案，如 <a href="https://zh.wikipedia.org/wiki/協作版本系統" target="_blank" rel="noopener">CVS</a> 的架构，受到 <a href="https://zh.wikipedia.org/wiki/林纳斯·托瓦兹" target="_blank" rel="noopener">林纳斯·托瓦兹</a> 的批评。</p><p>2005 年，<a href="https://zh.wikipedia.org/wiki/安德魯·垂鳩" target="_blank" rel="noopener">安德鲁·垂鸠</a>写了一个简单程序，可以连接 BitKeeper 的存储库，BitKeeper 著作权拥有者<a href="https://zh.wikipedia.org/wiki/拉里·麥沃伊" target="_blank" rel="noopener">拉里·麦沃伊</a> 认为 <a href="https://zh.wikipedia.org/wiki/安德魯·垂鳩" target="_blank" rel="noopener">安德鲁·垂鸠</a> 对 BitKeeper 内部使用的协议进行逆向工程，决定收回无偿使用 BitKeeper 的许可。Linux 内核开发团队与 BitMover 公司进行磋商，但无法解决他们之间的歧见。<a href="https://zh.wikipedia.org/wiki/林纳斯·托瓦兹" target="_blank" rel="noopener">林纳斯·托瓦兹</a> 决定自行开发版本控制系统替代 BitKeeper ，以 <code>十天</code> 的时间编写出 Git 第一个版本。</p><h4 id="Git-是什么？"><a href="#Git-是什么？" class="headerlink" title="Git 是什么？"></a>Git 是什么？</h4><p>Git 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 提供代码追踪，版本回溯等等功能，其实简单一句话来说，Git 就是项目版本管理的工具！</p><h4 id="Git-与-Github-什么关系？"><a href="#Git-与-Github-什么关系？" class="headerlink" title="Git 与 Github 什么关系？"></a>Git 与 Github 什么关系？</h4><p>Git 只是一个工具，而 Github 是一个代码托管的仓库。而 Git 可以去操作仓库，二者都是配合着使用。当然 Github 是国外免费的仓库，国内的免费仓库我们用的最多的是码云。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h5 id="1、设置用户名和邮箱帐号"><a href="#1、设置用户名和邮箱帐号" class="headerlink" title="1、设置用户名和邮箱帐号"></a>1、设置用户名和邮箱帐号</h5><pre><code>git config --global user.name  &quot;your user name&quot;git config --global user.email &quot;your email&quot;</code></pre><h5 id="2、克隆项目"><a href="#2、克隆项目" class="headerlink" title="2、克隆项目"></a>2、克隆项目</h5><pre><code># 当我们克隆项目时，可以选择 HTTPS 和 SSH git clone 项目 github 地址SSH   一次操作永久生效，当然也需要配置密钥HTTPS 每次都需要输入账号与密码</code></pre><h5 id="3、生成密钥密钥"><a href="#3、生成密钥密钥" class="headerlink" title="3、生成密钥密钥"></a>3、生成密钥密钥</h5><pre><code># 生成密钥，连续三下空格ssh-keygen -t rsa -b 4096 -C &quot;your email&quot;# 读取公钥配置，Gitee 或 Github 当中设置 SSH Keycat ~/.ssh/id_rsa.pub</code></pre><h5 id="4、修改-Git-连接方式"><a href="#4、修改-Git-连接方式" class="headerlink" title="4、修改 Git 连接方式"></a>4、修改 Git 连接方式</h5><pre><code># 如果开始选择的 HTTPS 连接方式，那么配置密钥后可以选择 SSH 连接，这样就可以免密操作vim .git/config## 修改前[remote &quot;origin&quot;]    url = https://gitee.com/xx/xxx.git    fetch = +refs/heads/*:refs/remotes/origin/*## 修改后[remote &quot;origin&quot;]    url = git@gitee.com:xx/xx.git    fetch = +refs/heads/*:refs/remotes/origin/*</code></pre><h4 id="Git-关键知识点"><a href="#Git-关键知识点" class="headerlink" title="Git 关键知识点"></a>Git 关键知识点</h4><p>工作区：添加、编辑、修改，删除等操作</p><p>暂存区：暂存已修改的文件、最后一起入版本库</p><p>版本库：也叫本地版本库，因为 Git 是分布式版本控制系统，大部分提交都是对本地仓库而言的，不依赖网络，最后一次会推送的到远程仓库。此时对外不可见</p><p>最终入库：确定都没问题保存到仓库、成为一个新的版本，并且外可见</p><p>个人感觉知道这四点就可以了，在深入那么就是 Git 专家了，我们平常使用不会有太深层的东西！</p><h4 id="简单流程"><a href="#简单流程" class="headerlink" title="简单流程"></a>简单流程</h4><pre><code># 查看状态，工作区git status# 提交到暂存区git add . 或 文件地址 // . 代表所有# 提交版本库，对外不可见，本地仓库git commit -m &#39;操作备注&#39; // 操作备注是个好习惯，一定要注释详细# 拉取更新，以防冲突git pull origin master# 最终入库，这一步一定要确认正确无误！对外可见git push origin master</code></pre><p><img src="https://i.loli.net/2020/04/07/Z4BECwmIMVpyuUH.png" alt="深度截图_选择区域_20200407212112.png"></p><p><img src="https://i.loli.net/2020/04/07/tXJMUNuCwcayBlk.png" alt="深度截图_选择区域_20200407212241.png"></p><h4 id="简单流程详解"><a href="#简单流程详解" class="headerlink" title="简单流程详解"></a>简单流程详解</h4><h5 id="1、查看状态，可以看见工作区的：增、删、改"><a href="#1、查看状态，可以看见工作区的：增、删、改" class="headerlink" title="1、查看状态，可以看见工作区的：增、删、改"></a>1、查看状态，可以看见工作区的：增、删、改</h5><pre><code>git status</code></pre><p><img src="https://i.loli.net/2020/04/07/uWZcGX9gKsOlJfp.png" alt="深度截图_选择区域_20200407212838.png"></p><h5 id="2、抛弃工作区：改、删"><a href="#2、抛弃工作区：改、删" class="headerlink" title="2、抛弃工作区：改、删"></a>2、抛弃工作区：改、删</h5><pre><code># 方法一 无法抛弃增加git checkout . 或 文件地址 // . 代表所有# 方法二 无法抛弃增加git restore . 或 文件地址 // . 代表所有</code></pre><p><img src="https://i.loli.net/2020/04/07/TXml5xJ37CPcukY.png" alt="深度截图_选择区域_20200407213221.png"></p><p><img src="https://i.loli.net/2020/04/07/Li5SYygn7hRdW4F.png" alt="深度截图_选择区域_20200407213402.png"></p><h5 id="3、添加到暂存区"><a href="#3、添加到暂存区" class="headerlink" title="3、添加到暂存区"></a>3、添加到暂存区</h5><pre><code>git add . 或 文件地址 // . 代表所有</code></pre><p><img src="https://i.loli.net/2020/04/07/8ISEzARQpelxdO7.png" alt="深度截图_选择区域_20200407221459.png"></p><h5 id="4、取消暂存"><a href="#4、取消暂存" class="headerlink" title="4、取消暂存"></a>4、取消暂存</h5><pre><code>git restore --staged  或 文件地址 // . 代表所有</code></pre><p><img src="https://i.loli.net/2020/04/07/wWl1yMtPHVkF5aD.png" alt="深度截图_选择区域_20200407221936.png"></p><h5 id="5、提交版本库，对外不可见"><a href="#5、提交版本库，对外不可见" class="headerlink" title="5、提交版本库，对外不可见"></a>5、提交版本库，对外不可见</h5><pre><code>git commit -m &#39;操作备注&#39; // 操作备注是个好习惯，一定要注释详细</code></pre><p><img src="https://i.loli.net/2020/04/07/iJqodIUkE6CA7hZ.png" alt="深度截图_选择区域_20200407222339.png"></p><h5 id="6、回滚本地仓库"><a href="#6、回滚本地仓库" class="headerlink" title="6、回滚本地仓库"></a>6、回滚本地仓库</h5><pre><code># 查看日志，查看日志后按 q 才能退出日志git log                  # 常用命令一，比较暴力:重置 HEAD、索引和工作区git reset --herd ID         // 回滚到指定的版本git reset --hard HEAD^   // 回退到上个版本git reset --hard HEAD~3  // 回退到前 3 次提交之前，以此类推，回退到 n 次提交之前# 常用命令二，稍微温柔:重置 HEADgit reset --soft ID# 其他命令    -q, --quiet           安静模式，只报告错误    --mixed               重置 HEAD 和索引    --merge               重置 HEAD、索引和工作区    --keep                重置 HEAD 但保存本地变更</code></pre><p><img src="https://i.loli.net/2020/04/07/VPiJlgUMyfXD547.png" alt="深度截图_选择区域_20200407223542.png"></p><p><img src="https://i.loli.net/2020/04/07/oNrseyhKltidmOa.png" alt="深度截图_选择区域_20200407224056.png"></p><h5 id="7、确认无误，拉取更新，最终入库，对外可见"><a href="#7、确认无误，拉取更新，最终入库，对外可见" class="headerlink" title="7、确认无误，拉取更新，最终入库，对外可见"></a>7、确认无误，拉取更新，最终入库，对外可见</h5><pre><code># 拉取更新，确认无冲突git pull origin master# 确认无误，最终入库，对外可见git push origin master</code></pre><p><img src="https://i.loli.net/2020/04/07/Uwuli13d26QhWKY.png" alt="深度截图_选择区域_20200407225246.png"></p><p><img src="https://i.loli.net/2020/04/07/jR7NOp6vUtmzK4d.png" alt="深度截图_选择区域_20200407225437.png"></p><pre><code>未完待续...</code></pre><blockquote><p>参考地址：</p><p><a href="https://zh.wikipedia.org/wiki/Git" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Git</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-学习笔记</title>
      <link href="/2020/02/28/Golang-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/28/Golang-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Go 是一门全新的语言。尽管它从现有的语言中借鉴了许多理念，但其与众不同的特性， 使得使用 Go 编程在本质上就不同于其它语言。做为 PHP 开发人员，第二门语言选 Go 的同撩还是比较多，从此可以论证 Go 还是非常值得学习！第一次听说 Go 还是在 Swoole 当中的协程板块当中看见。刚好最近公司事情不多可以学习学习扩充自己。</p><p><strong>Go 特性对比大多数语言：</strong></p><ol><li>为了简化设计，不支持函数重载和操作符重载</li><li>为了避免在 C/C++ 开发中的一些 Bug 和混乱，不支持隐式转换</li><li>Go 语言通过另一种途径实现面向对象设计（结构）来放弃类和类型的继承，尽管在接口的使用方面可以实现类似变体类型的功能，但本身不支持变体类型</li><li>不支持动态加载代码</li><li>不支持动态链接库</li><li>不支持泛型</li><li>通过 recover 和 panic 来替代异常机制</li><li>不支持断言</li><li>不支持静态变量</li></ol><h4 id="GO-语言很特别"><a href="#GO-语言很特别" class="headerlink" title="GO 语言很特别"></a>GO 语言很特别</h4><p>没有 “对象”，没有继承、多态，没有泛型，没有 try/catch</p><p>有接口，函数式编程，CSP 并发编程（goroutine + channel）</p><blockquote><p>参考地址：</p><p>Go 社区入门文档，<a href="https://learnku.com/docs/the-way-to-go/preface/3561" target="_blank" rel="noopener">https://learnku.com/docs/the-way-to-go/preface/3561</a></p><p>慕课网 《Google 资深工程师深度讲解 Go 语言》 <a href="https://coding.imooc.com/class/chapter/180.html#Anchor" target="_blank" rel="noopener">https://coding.imooc.com/class/chapter/180.html#Anchor</a></p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>从 Go 语言中文网：<a href="https://studygolang.com/dl" target="_blank" rel="noopener">Go 中文社区</a> 上下载合适的 二进制发行版，根据自己操作系统而定二进制文件</p><pre><code>$ sudo tar -xzf go1.13.6.linux-amd64.tar.gz -C /usr/local</code></pre><p>建立软链接</p><pre><code>$ sudo ln -s /usr/local/go/bin/* /usr/bin/</code></pre><p>测试</p><pre class="line-numbers language-、"><code class="language-、">go version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有出现问题，那么就算装好了。接下来就是设置 Go 的开发环境了</p><pre><code>$ sudo vim $HOME/.bashrc# 如果是zsh,就把/.bashrc 改成 /.zshrc</code></pre><p>编辑以下内容然后保存退出</p><pre><code>export GOROOT=/usr/local/go   # 表示 Go 在你的电脑上的安装位置，有些安装包会自动设置默认的 gorootexport GOPATH=$HOME/go-work   # 默认安装包的路径,根据自己需要来选择位置export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</code></pre><p>使配置文件生效，这里有个大坑，千万别用 fish 里面执行它一直报错，人都差点搞死了</p><pre><code>$ source $HOME/.bashrc　</code></pre><p>可运行 go env 查看 Go 环境变量</p><pre><code>go env</code></pre><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p><strong>国际惯例 Hello World</strong></p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello world"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go 是由包组成的，包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。</p><p>如同其它一些编程语言中的类库或命名空间的概念，<strong>每个 Go 文件都属于且仅属于一个包</strong>。一个包可以由许多以 <code>.go</code> 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。</p><p>你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：<code>package main</code>。<code>package main</code> 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 <code>main</code> 的包。</p><p>一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 package main 来指明这些文件都属于 main 包。如果你打算编译包名不是为 main 的源文件，如 pack1，编译后产生的对象文件将会是 pack1.a 而不是可执行程序。另外要注意的是，所有的包名都应该使用小写字母。</p><p><strong>注意事项</strong></p><ul><li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Account，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为<code>导出</code>（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。</li><li>当二个包当中有相同的命名冲突时，我们可以使用 <code>包名.名称</code>帮助避免命名冲突（名称冲突）：两个包中的同名变量的区别在于他们的包名，例如 <code>pack1.Thing</code> 和 <code>pack2.Thing</code>。</li><li>当二个包命名冲突时，我们可以使用包别名来解决包名称之间的冲突，或者说根据你的个人喜好对包名进行重新设置。如：<code>import echo &quot;fmt&quot;、import print &quot;fmt&quot;</code>，在使用那么就是 <code>echo.Print、print.Print</code>。</li><li>如果你导入了一个包却没有使用它，则会在构建程序时引发错误，如 <code>imported and not used: os</code>，这正是遵循了 Go 的格言：“没有不必要的代码！“。</li><li>你可以在使用 <code>import</code> 导入包之后定义或声明 0 个或多个常量（const）、变量（var）和类型（type），这些对象的作用域都是全局的（在本包范围内），所以可以被本包中所有的函数调用。</li></ul><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量使用关键字 <code>const</code> 定义，用于存储不会改变的数据。基础理解和 PHP 没啥差别，但是 Go 当中声明数据时候非常的多元化，不能说这样就比 PHP 好，PHP 也有二个派系，静态强制类型喜好者（本人就是其中之一），动态敏捷开发喜好者（我一同事非常喜爱）。所以，语言无好坏全看各人喜好来！</p><p>存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。常量的值必须是能够在编译时就能够确定的，所以定义常量时必须赋值。</p><p>1、显式类型声明</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">const</span> pi <span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token number">3.1415</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、隐式类型声明</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">const</span> pi <span class="token operator">=</span> <span class="token number">3.1415</span># 当在我们隐式声明常量或变量时，设计到有关系统架构的数据类型时，那么他的类型就是根据系统架构来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3、多元化声明</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">const</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token keyword">const</span> <span class="token punctuation">(</span>    a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>    a<span class="token punctuation">,</span>c <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">(</span>    a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">1</span>    b <span class="token builtin">bool</span> <span class="token operator">=</span> <span class="token boolean">true</span>    c <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">)</span># Go 当中的字符串都是使用双引号，无法使用单引号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、普通枚举声明</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>    a <span class="token operator">=</span> <span class="token number">1</span>    b <span class="token operator">=</span> <span class="token number">2</span>    c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5、自增枚举声明，利用的是 <code>iota</code>，在每遇到一个新的常量块或单个常量声明时， <code>iota</code> 都会重置为 0（ <strong>简单地讲，每遇到一次 const 关键字，iota 就重置为 0</strong> ）。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>    a <span class="token operator">=</span> <span class="token boolean">iota</span>    b    c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>6、高级枚举声明，参与运算</p><pre class="line-numbers language-go"><code class="language-go"># 高级枚举，参与运算<span class="token keyword">const</span> <span class="token punctuation">(</span>    k <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token boolean">iota</span><span class="token punctuation">)</span>    kb    mb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意事项：</strong></p><ol><li>因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len ()。</li><li>数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出。</li></ol><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>声明变量可以使用 <code>var</code> 关键字或者简写 <code>:=</code>二种方式都可以声明变量。</p><p>1、显式声明变量</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">var</span> s <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2、隐式声明变量</p><pre class="line-numbers language-go"><code class="language-go"># 正常 <span class="token keyword">var</span> 声明变量<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">"hello"</span># 使用 <span class="token operator">:=</span> 简写声明变量a <span class="token operator">:=</span> <span class="token number">1</span>s <span class="token operator">:=</span> <span class="token string">"world"</span># 当在我们隐式声明常量或变量时，设计到有关系统架构的数据类型时，那么他的类型就是根据系统架构来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、多元化定义变量</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token builtin">int</span><span class="token keyword">var</span> s1<span class="token punctuation">,</span>s2 <span class="token builtin">string</span><span class="token keyword">var</span> <span class="token punctuation">(</span>    a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token builtin">int</span>    s1<span class="token punctuation">,</span>s2 <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token keyword">var</span> <span class="token punctuation">(</span>    a <span class="token builtin">int</span>    b <span class="token builtin">int</span>    c <span class="token builtin">int</span>    d <span class="token builtin">int</span>    s1 <span class="token builtin">string</span>    s2 <span class="token builtin">string</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、定义变量并且赋值，<strong>我们定义了多少个变量，赋值时必须全部给定义的变量赋值</strong></p><pre class="line-numbers language-go"><code class="language-go"># 定义一个变量并且赋值<span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">var</span> s <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"hello world"</span># 定义多个变量并且赋值<span class="token keyword">var</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token keyword">var</span> s1<span class="token punctuation">,</span>s2 <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token string">"world"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意事项</strong></p><ol><li>定义了一个变量，那么就必须去使用这个变量，否则会报错，遵循 Go 的格言：“没有不必要的代码”。</li><li>在函数或其他关键字内部（局部）可以使用 <code>:=</code> 代替 <code>var</code>，在包内部（全局）无法使用 <code>:=</code> 代替 <code>var</code>，也就是说全局下不能使用 <code>:=</code>，另外 <code>:=</code> 没有定义类型编译器可以根据变量的值来自动推断其类型。</li><li>数据类型只有强制数据类型转换，无法进行隐式类型转换。这点对于我们 PHPer 来说开始还是有点难以习惯的一点。</li><li>当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。记住，所有的内存在 Go 中都是经过初始化的。</li><li>使用空白符号 <code>_</code> 可以抛弃一个变量。</li><li>Go 对于值之间的比较有非常严格的限制，只有两个类型相同的值才可以进行比较，如果值的类型是接口，它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值的类型必须和该常量类型相兼容的。如果以上条件都不满足，则其中一个值的类型必须在被转换为和另外一个值的类型相同之后才可以进行比较。</li></ol><h4 id="内建变量类型"><a href="#内建变量类型" class="headerlink" title="内建变量类型"></a>内建变量类型</h4><h5 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h5><p>bool 只有二个值（常量）  true 或 false，跟 PHP 当中的不同 1 和 0 无法代表 true 或 false，Go 当中的 bool 有且只有 true 或 false</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> a <span class="token builtin">bool</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token keyword">var</span> a <span class="token builtin">bool</span> <span class="token operator">=</span> <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><p>string 只可以用<code>&quot;&quot;</code>表示，不可以用 <code>&#39;&#39;</code>，使用 <code>+</code>可以进行字符串连接</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> a <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"您好，世界"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h5><p>整型：(u)int、(u)int8、(u)int16、(u)int32、(u)int64、uintprt(它属于指针)</p><p>整数：</p><ul><li>int8（-128 -&gt; 127）</li><li>int16（-32768 -&gt; 32767）</li><li>int32（-2,147,483,648 -&gt; 2,147,483,647）</li><li>int64（-9,223,372,036,854,775,808 -&gt; 9,223,372,036,854,775,807）</li></ul><p>无符号整数：</p><ul><li>uint8（0 -&gt; 255）</li><li>uint16（0 -&gt; 65,535）</li><li>uint32（0 -&gt; 4,294,967,295）</li><li>uint64（0 -&gt; 18,446,744,073,709,551,615）</li></ul><blockquote><p>这些类型当中，int、uint、unitprt 属于平台架构类型</p><p>这些类型的长度都是根据运行程序所在的操作系统类型所决定的：</p><p>int 和 uint 在 32 位操作系统上，它们均使用 32 位（4 个字节），在 64 位操作系统上，它们均使用 64 位（8 个字节）。<br>uintptr 的长度被设定为足够存放一个指针即可。</p></blockquote><p>浮点型：float32、float64</p><p>浮点型（IEEE-754 标准）：</p><ul><li>float32（+- 1e-45 -&gt; +- 3.4 * 1e38）</li><li>float64（+- 5 <em>1e-324 -&gt; 107</em> 1e308）</li></ul><blockquote><p>float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。float 类型的精度都不是很准确。使用 == 或 != 需要注意精度问题。</p></blockquote><p>复数型：complex64 (32 位实数和虚数) 、complex128 (64 位实数和虚数)</p><blockquote><p>复数使用 <code>re+imI</code> 来表示，其中 <code>re</code> 代表实数部分，<code>im</code> 代表虚数部分，<code>I</code> 代表根号负 1。</p></blockquote><h5 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h5><p>严格意义上讲 ，这并不是 Go 的一个类型，字符只是整数的特殊用列。<code>byte</code> 类型是 <code>uint8</code> 的别名。<code>rune</code> 类型是 <code>int32</code> 的别名。在 Go 当中英文是 1 个字节，中文是 3 个字节。使用 rune 后 中文英文都是一个字节。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> s <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"hello你好"</span>b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>c <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/home/golang/.config/Typora/typora-user-images/image-20200226211102601.png" alt="image-20200226211102601"></p><h5 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h5><p>当你在使用某个类型时，你可以给它起另一个名字，然后你就可以在你的代码中使用新的名字（用于简化名称或解决名称冲突）。</p><p>在 type TZ int 中，TZ 就是 int 类型的新名称（用于表示程序中的时区），然后就可以使用 TZ 来操作 int 类型的数据。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> TZ <span class="token builtin">int</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>首先大家都知道，程序在内存当中存储它的值，每个内存块（或字）都有一个地址，通常都是十六进制表示。Go 语言的取地址符是 <code>&amp;</code>，放到一个变量前使用就会返回相应变量的内存地址。</p><pre><code>var a int = 100fmt.Print(&amp;a) // 0x549100</code></pre><p>Go 实现指针比较简单 <code>var a *int</code>只需要在类型前面加上一个<code>*</code>即可使用指针，使用指针时，也只需要在使用者前面加上一个<code>*</code>即可使用，注意一点：Go 的指针跟比的语言都点不一样，他们<strong>不能进行指针运算操作</strong>。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">var</span> b <span class="token operator">*</span><span class="token builtin">int</span>b <span class="token operator">=</span> <span class="token operator">&amp;</span>afmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0x54a100 0x54a100 b 和 a 的内存地址一样</span><span class="token operator">*</span>b <span class="token operator">=</span> <span class="token operator">*</span>b <span class="token operator">+</span> <span class="token number">100</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>b<span class="token punctuation">,</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 200 200</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><h5 id="if"><a href="#if" class="headerlink" title="if"></a>if</h5><pre class="line-numbers language-go"><code class="language-go"># 第一中写法<span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">if</span> a <span class="token operator">></span> <span class="token number">10</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span># 第二种写法<span class="token keyword">if</span> a <span class="token operator">:=</span> <span class="token number">10</span><span class="token punctuation">;</span>a <span class="token operator">></span> <span class="token number">5</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h5><pre class="line-numbers language-go"><code class="language-go"># 第一中写法<span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">switch</span> a <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token keyword">case</span> <span class="token number">5</span> <span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">2</span>    <span class="token keyword">default</span> <span class="token punctuation">:</span><span class="token punctuation">}</span># 第二种写法<span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">switch</span><span class="token punctuation">{</span>    <span class="token keyword">case</span> a <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">true</span>    <span class="token keyword">case</span> a <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">for</span> 初始化语句<span class="token punctuation">;</span> 条件语句<span class="token punctuation">;</span> 修饰语句 <span class="token punctuation">{</span><span class="token punctuation">}</span># 第一中写法<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">{</span><span class="token punctuation">}</span># 第二种写法 省略初始化语句<span class="token keyword">for</span> <span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">5</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">{</span><span class="token punctuation">}</span># 第三中写法 省略 装饰语句<span class="token keyword">for</span> i <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">{</span><span class="token punctuation">}</span># 第四种写法 死循环<span class="token keyword">for</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>Go 当中定义数组也是多元化的操作</p><pre class="line-numbers language-go"><code class="language-go"># 第一种定义方式<span class="token keyword">var</span> arr <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span>定义一个一维数组，<span class="token number">3</span>个下标# 第二种定义方式arr <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span>定义一个一维数组，<span class="token number">3</span>个下标，使用 <span class="token operator">:=</span> 必须赋值# 第三种定义方式arr <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span>定义一个一维数组，<span class="token number">3</span>个下标，使用 <span class="token operator">:=</span> 必须赋值，可以默认多个下标# 第四种定义方式<span class="token keyword">var</span> arr <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token builtin">string</span>定义一个二维数组# 第五种写法<span class="token keyword">var</span> arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>定义一个 slice ，此时 arr 的值就是 <span class="token boolean">nil</span>arr <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span>arr <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>arr <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">)</span>以上都可以创建 slice <span class="token builtin">make</span> 创建 slice  第二参数和第三个参数分别为 slice 的 <span class="token builtin">len</span> 长度 和 slice 的 <span class="token builtin">cap</span> 长度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组循环</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span># 第一种写法<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> arr<span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span># 第二种写法<span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token operator">:=</span> <span class="token keyword">range</span> arr<span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>[10]int 和 [11]int 是不同的类型。</strong></p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>slice 本身是没有数据的，是对底层 array 的 view，<code>[:]</code> 就表示 slice ，使用了 slice 那么也就相当与是使用了指针，也就是说的引用传值。slice 底层有一个 array，由 prt、len、cap 组成。prt： slice 开头的那个元素，len：slice 的长度是多少 用 [] 能取到多少，cap：从 prt 到 array 整个的结束。</p><pre><code>var arr = [...]int{1, 2, 3, 4, 5, 6, 7}# 切片从第 0 个下标取到最后一个下标，那么这个切片就是 1,2,3,4,5,6,7slice1 := arr[:]# 切片从第一个下班取到第三个下标，那么这个切片就是 2,3slice2 := arr[1:3]# 切片从第 0 个下班取到第二个下标，那么这个切片就是 1,2slice3 := arr[:2]# 切片从地一个下标取到最后一个下标，那么这个切片就是 2,3,4,5,6,7slice4 := arr[1:]fmt.Println(arr,slice1,slice2,slice3,slice4)</code></pre><p>slice 可以向后扩展，但是不可以向前扩展。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span># 第二个下标到第六个下标，结果：<span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span>slice <span class="token operator">:=</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span># 第一个下标到第三个下标，结果：<span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span>slice1 <span class="token operator">:=</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span># 第三个下标到第五个下标，结果<span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span> <span class="token punctuation">,</span>此时 slice <span class="token builtin">cap</span> 到整个 array 结束后面还有一个值 <span class="token number">7</span> slice2 <span class="token operator">:=</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span># 此时报错，已经超过了 <span class="token builtin">cap</span> 的最大取值slice3 <span class="token operator">:=</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>slice 可以添加元素，如果超越 cap，系统会重新分配更大的底层数组，如果之前的数组没有在使用那么 Go 的垃圾回收机制就会自动的帮我们回收掉。</p><pre><code># 添加var arr = [...]int{1, 2, 3, 4, 5, 6, 7}slice1 := arr[2:6]//3,4,5,6sliceCap1 := append(slice1,7,8,9)//3,4,5,6,7,8,9sliceCap2 := append(sliceCap2,10,11,12)//3,4,5,6,7,8,9,10,11,12sliceCap3 := append(arr[:2],sliceCap1[2:]...) // 意思是 arr 从下标0到下标1,sliceCap1 从下标2到最后组成的新数组# 删除var arr = []int{1, 2, 3, 4, 5, 6, 7}// 1,2,3,4,5,6,7 删除 3 arr = append(arr[:2],arr[3:]...) // 1,2，4,5,6,7arr = arr[1:] // 删除头aar = arr[:len(arr) - 1] // 删除尾# 注意：append 属于值传递，需要接受返回值</code></pre><p>slice 操作</p><pre class="line-numbers language-go"><code class="language-go"># 拷贝<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span> sliceCopy <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 9,8</span>slice1 <span class="token operator">:=</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 3,4,5,6</span><span class="token function">copy</span><span class="token punctuation">(</span>sliceCopy<span class="token punctuation">,</span>slice1<span class="token punctuation">)</span> sliceCopy <span class="token comment" spellcheck="true">// 此时值就是 3，4</span># 注意：<span class="token builtin">copy</span> 属于引用传值无需接受返回值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>再次注意一个问题 [7]int 和 [6]int 他们不是相同类型</strong></p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><pre><code># map 的格式map[k]v、map[k1]v1map[k2]v2 -&gt; 此为复合 map# 定义一个 mapvar m map[string]intvar m2 = make(map[string]int)m3 := map[string]int{    &quot;a&quot;:1,}# 循环 map 跟数组一样的操作m3 := map[string]int{    &quot;age&quot;:23,    &quot;height&quot;: 170,}# 获取 valueage := m3[&quot;age&quot;] // 如果没有这个 Key 那么不会报错，获取 value 的初始值或者说 nil# 判断值是否存在age ，ok := m3[&quot;age&quot;]if age,ok := m3[&quot;age&quot;]; ok {    fmt.Println(age)}else {    fmt.Println(&quot;error age does not exist &quot;)}# 删除值delete(m3,&quot;height&quot;)# 获取元素个数len(m3)</code></pre><p>map 是无序的，如果需要排序那么我们就的结合 slice 来处理。几乎所有的内建类型都可以作为 key，除了 slice map function的内建类型都可以作为 key。</p><h3 id="面向“对象”"><a href="#面向“对象”" class="headerlink" title="面向“对象”"></a>面向“对象”</h3><p>Go 语言只支持封装，不支持继承和多态。在 Go 语言当中，所有参数都是值拷贝传递，结构也不例外。Go 当中虽然没有 Class，但是结构可以看作为 Class 。</p><pre><code># 定义结构格式type &lt;结构名称&gt; struct{}# 定义地一个结构type person struct{    age int    name string}# 使用结构func main() {    a := person{}    a.age = 100    a.name = &quot;张飞&quot;    fmt.Print(a)}# 初始化结构，跟 PHP 类当中的构造 __construct 一个意思，也推荐初始化用取地址符号 &amp; 用作指针操作func main() {    a := &amp;person{        age:100,        name:&quot;张飞&quot;    }    a.age = 200 # 在 Go 当中指针不需要 *a.age 这样来操作}# 匿名结构func main() {    a := struct {        age int        name string    }{        age:100,        name:&quot;关羽&quot;,    }}# 匿名结构嵌套type person struct {    age int    name string    detailed struct{        sex string        height int    }}# 匿名结构嵌套初始化func main() {    a := person{        age:  100,        name: &quot;张飞&quot;,        detailed: struct {        sex    string        height int    }{            sex:&quot;男&quot;,            height:180,      },    }    fmt.Print(a)}# 结构字段匿名,需要注意的是初始化时给的值必须是规定的字段类型type person struct{    string    int}</code></pre><p> 嵌入 组合</p><pre><code># a 当中有 3 个属性，b 和 c 都可以得到使用，这就是组合跟继承有些那么像是type a struct{    sex,age int    name string}type b struct{    a}type c struct{    a}func main() {    b := b{a{        sex:  1,        age:  100,        name: &quot;吕布&quot;,    }}    c := c{a{        sex:  0,        age:  90,        name: &quot;貂蝉&quot;,    }}    b.sex = 0    b.name = &quot;貂蝉&quot;    b.age = 90    c.sex = 1    c.name = &quot;吕布&quot;    c.age = 100    fmt.Println(&quot;b&quot;,b,&quot;c&quot;,c)}嵌入，需要注意一点，同级别有相同的熟悉会报错，不是同一级别那么不会报错。</code></pre><p>结构方法</p><pre><code># 定义结构方式，跟定义函数差不多func (a a) print() {    # func 后面的括号就是接收者，接收也就是我们的结构，在后面才是方法名称}</code></pre><p>在 Go 当中所有的首字母大写都是：public</p><p>在 Go 当中所有的首字母小写都是：provate</p><p>他们针对的都是对于包来说(package)，在同一个包里面其实这些区别不大。</p><p>每个目录只能有一个包，main 包包含程序可以执行入口，如果这个目录下面有了一个 main 函数那么这个目录下面就只能有一个 main 包。为结构定义的方法，必须放在同一个包内。如果一个结构的方法很多，可以是多个文件</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>duck typing</p><blockquote><p>学习当中，最近忙得不可言语</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-读写分离</title>
      <link href="/2020/02/18/Mysql-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2020/02/18/Mysql-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>binlog 是 Mysql Sever 层维护的一种二进制日志，与 innodb 引擎中的 redo/undo log 是完全不同的日志；其主要是用来记录对 Mysql 数据更新或潜在发生更新的 SQL 语句，记录了所有的 DDL 和 DML (除了数据查询语句)语句，并以<code>事务</code>的形式保存在磁盘中，还包含语句所执行的消耗的时间，Mysql 的二进制日志是事务安全型的。</p><p>一般来说开启二进制日志大概会有 1% 的性能损耗(参见 MySQL 官方中文手册 5.1.24 版)。</p><p>作用主要有：</p><ul><li>复制：MySQL Replication在 Maste r端开启 binlog，Master 把它的二进制日志传递给 slaves 并回放来达到 master-slave 数据一致的目的 </li><li>数据恢复：通过 mysqlbinlog 工具恢复数据</li><li>增量备份</li></ul><p>二进制日志包括两类文件：二进制日志索引文件（文件名后缀为.index）用于记录所有的二进制文件，二进制日志文件（文件名后缀为.00000*）记录数据库所有的 DDL 和 DML (除了数据查询语句)语句事件。</p><h3 id="主数据库"><a href="#主数据库" class="headerlink" title="主数据库"></a>主数据库</h3><pre><code>1、修改 Mysql 配置文件  注：Mysql 5.7.2 以后没有默认配置了，一切配置需要自行配置vim /etc/mysql/my.cnfserver-id=1           # 服务器唯一IDlog-bin=mysql-bin     # mysql-bin日志前缀，可自定义binlog-do-db=db1,db2  # 需要同步的库binlog-ignore-db=db1,db2 # 忽略不同步的库binlog 两参数2选1 都不写全部同步2、查询 bin-log 是否开启show variables like &#39;%log_bin%&#39;;+---------------------------------+--------------------------------+| Variable_name                   | Value                          |+---------------------------------+--------------------------------+| log_bin                         | ON                             || log_bin_basename                | /var/lib/mysql/mysql-bin       || log_bin_index                   | /var/lib/mysql/mysql-bin.index || log_bin_trust_function_creators | OFF                            || log_bin_use_v1_row_events       | OFF                            || sql_log_bin                     | ON                             |+---------------------------------+--------------------------------+6 rows in set (0.01 sec)3、在主服务器上建立帐户并授权# 以下为 5.x 版本 创建用户并且授权grant  replication slave  on *.*  to &#39;daofaziran&#39;@&#39;%&#39; identified by &#39;654321&#39;;# 以下为 8 版本 创建用户并且授权create user ‘daofaziran’@‘%’ identified by ‘123456’;grant all privileges on *.* to ‘daofaziran’@’%’ with grant option; flush privileges;4、查看状态show master status;# File 和 Position 要记录好+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 |      155 | wangzhuan    |                  |                   |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)</code></pre><h3 id="从数据库"><a href="#从数据库" class="headerlink" title="从数据库"></a>从数据库</h3><pre><code>1、修改 Mysql 配置文件 vim /etc/mysql/my.cnfserver-id=2           # 服务器唯一IDlog-bin=mysql-bin     # mysql-bin日志前缀以下可选参数：replicate-do-db=db1,db2replicate-ignore-db=db1,db22、进入mysqlstop slave; CHANGE MASTER TO  # 主服务器地址  MASTER_HOST=&#39;192.168.1.6&#39;,  # 主服务器账号  MASTER_USER=&#39;daofaziran&#39;,  # 主服务器密码  MASTER_PASSWORD=&#39;123456&#39;,  # 主服务器端口  MASTER_PORT=3306,  # 主服务器 binlog 日志文件名,对应的 show master status 的 File  MASTER_LOG_FILE=&#39;mysql-bin.000002&#39;,  # 主服务器日志记录起点位置，对应的  show master status 的 Position  MASTER_LOG_POS=155,  # 连接重试次数  MASTER_CONNECT_RETRY=10;start slave;# 查看是否配置成功show slave status;Slave_IO_Running:Yes 此进程负责从服务器从主服务器上读取binlog 日志，并写入从服务器上的中继日志。 Slave_SQL_Running:Yes 此进程负责读取并且执行中继日志中的binlog日志， 注：以上两个都为yes则表明成功</code></pre><p>binlog 日志操作的常用命令</p><pre><code># 执行该命令，就会产生一个新的 log-bin 日志flush logs;# 清空所有的log-bin日志，并产生一个新的 log-bin 日志reset master;#查看最后（新）的一个 log-bin 日志show master status;</code></pre><h3 id="Laravel-读写分离"><a href="#Laravel-读写分离" class="headerlink" title="Laravel 读写分离"></a>Laravel 读写分离</h3><pre><code>        &#39;mysql&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;mysql&#39;,            &#39;read&#39; =&gt; [                &#39;host&#39; =&gt; &#39;192.168.1.6&#39;,                &#39;port&#39; =&gt; &#39;3307&#39;,                &#39;password&#39; =&gt; &#39;root&#39;            ],            &#39;write&#39; =&gt; [                &#39;host&#39; =&gt; &#39;192.168.1.6&#39;,                &#39;port&#39; =&gt; &#39;3306&#39;,                &#39;password&#39; =&gt; &#39;root&#39;            ],            &#39;url&#39; =&gt; env(&#39;DATABASE_URL&#39;),//            &#39;host&#39; =&gt; env(&#39;DB_HOST&#39;, &#39;127.0.0.1&#39;),//            &#39;port&#39; =&gt; env(&#39;DB_PORT&#39;, &#39;3306&#39;),            &#39;database&#39; =&gt; env(&#39;DB_DATABASE&#39;, &#39;forge&#39;),            &#39;username&#39; =&gt; env(&#39;DB_USERNAME&#39;, &#39;forge&#39;),//            &#39;password&#39; =&gt; env(&#39;DB_PASSWORD&#39;, &#39;&#39;),            &#39;unix_socket&#39; =&gt; env(&#39;DB_SOCKET&#39;, &#39;&#39;),            &#39;charset&#39; =&gt; &#39;utf8mb4&#39;,            &#39;collation&#39; =&gt; &#39;utf8mb4_unicode_ci&#39;,            &#39;prefix&#39; =&gt; &#39;&#39;,            &#39;prefix_indexes&#39; =&gt; true,            &#39;strict&#39; =&gt; true,            &#39;engine&#39; =&gt; null,            &#39;options&#39; =&gt; extension_loaded(&#39;pdo_mysql&#39;) ? array_filter([                PDO::MYSQL_ATTR_SSL_CA =&gt; env(&#39;MYSQL_ATTR_SSL_CA&#39;),            ]) : [],        ],</code></pre><blockquote><p>参考地址：</p><p><a href="https://blog.51cto.com/zhongliang/2152917" target="_blank" rel="noopener">https://blog.51cto.com/zhongliang/2152917</a></p><p><a href="https://www.cnblogs.com/chenhaoyu/p/10773988.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenhaoyu/p/10773988.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-OSS</title>
      <link href="/2020/01/16/Laravel-OSS/"/>
      <url>/2020/01/16/Laravel-OSS/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>在项目当中，我们一般不会选择本地服务器存储访问资源，这样对于服务器来说的话也比较消耗资源。而第三方的存储服务器就可以帮我们解决这个问题。阿里云对象存储服务，简称 OSS，是一种面向海量数据规模的分布式存储服务，具有稳定、可靠、安全、低成本的特点，能够提供十一个九的数据可靠性。 OSS 提供与平台无关的 RESTful API 接口，您可以在互联网任何位置存储和访问。 OSS 的容量和处理能力弹性扩展，并提供多种存储类型供您选择，全面优化存储成本。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p> aliyuncs/<a href="https://packagist.org/packages/aliyuncs/oss-sdk-php" target="_blank" rel="noopener">oss-sdk-php</a></p><pre><code>$ composer require aliyuncs/oss-sdk-php</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>上传文件</p><pre><code>use OSS\OssClient;use OSS\Core\OssException;ry{     $oss = new OssClient(id,key,endpoint)    $result = $oss-&gt;uploadFile(bucket, 保存到 oss 的路径,上传文件的路径);} catch(OssException $e) {    ApiExceptionError(&#39;上传失败,请重新上传&#39;);}</code></pre><blockquote><p>未完代续</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-阿里云短信</title>
      <link href="/2020/01/16/Laravel-%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1/"/>
      <url>/2020/01/16/Laravel-%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>在我们大多数项目当中，短信服务属于必不可少的一种功能。接口平台也是多如牛毛。今天要介绍的这个包，包含了大多知名平台的短信服务接入，也是我目前使用过最好的一个短信服务扩展包。开发者也是 Learnku 知名人物 “超哥”开发，在这里也安利一下超哥的 PHP 扩展包开发实战教程：<a href="https://learnku.com/courses/creating-package" target="_blank" rel="noopener">点我跳转</a></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>支持目前市面多家服务商</li><li>一套写法兼容所有平台</li><li>简单配置即可灵活增减服务商</li><li>内置多种服务商轮询策略、支持自定义轮询策略</li><li>统一的返回值格式，便于日志与监控</li><li>自动轮询选择可用的服务商</li><li>更多等你去发现与改进…</li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://packagist.org/packages/overtrue/easy-sms" target="_blank" rel="noopener">EasySms</a> </p><pre><code>$ composer require overtrue/easy-sms</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>以下以阿里云为例子，我们可以在 config 目录当中新建一个 aliyun.php 配置文件，当然也可以直接使用。</p><pre><code>return [    &#39;aliyun&#39; =&gt; [        // HTTP 请求的超时时间（秒）        &#39;timeout&#39; =&gt; 5.0,        // 默认发送配置        &#39;default&#39; =&gt; [            // 网关调用策略，默认：顺序调用            &#39;strategy&#39; =&gt; \Overtrue\EasySms\Strategies\OrderStrategy::class,            // 默认可用的发送网关            &#39;gateways&#39; =&gt; [                &#39;aliyun&#39;,            ],        ],        // 可用的网关配置        &#39;gateways&#39; =&gt; [            &#39;errorlog&#39; =&gt; [                &#39;file&#39; =&gt; &#39;/tmp/easy-sms.log&#39;,            ],            &#39;aliyun&#39; =&gt; [                &#39;access_key_id&#39; =&gt; env(&#39;ACCESS_KEY_ID&#39;),                &#39;access_key_secret&#39; =&gt; env(&#39;ACCESS_KEY_SECRET&#39;),                &#39;sign_name&#39; =&gt; env(&#39;SIGN_NAME&#39;),// 阿里云的签名            ],        ],    ],    &#39;template&#39; =&gt; env(&#39;ALIYUN_TEMPLATE&#39;),// 阿里云的模板 ID];</code></pre><pre><code>use Overtrue\EasySms\EasySms;$easySms = new EasySms(config(&#39;aliyun.aliyun&#39;));$code = str_pad(random_int(1, 999999), 6, 0, STR_PAD_LEFT);try{    $result = $easySms-&gt;send(‘手机号码’, [        &#39;template&#39; =&gt; config(&#39;aliyun.template&#39;), // 模板 ID        &#39;data&#39; =&gt; [            &#39;number&#39; =&gt; $code // data 里面传递的就是你的模板变量，        ],    ],[&#39;aliyun&#39;]);     }catch (\GuzzleHttp\Exception\ClientException $exception){         $response = $exception-&gt;getResponse();         $result = json_decode($response-&gt;getBody()-&gt;getContents(), true);         return $this-&gt;response-&gt;errorInternal($result[&#39;msg&#39;]??&#39;短信发送异常&#39;);     }</code></pre><p>正常的流程情况下如果出现发送失败或者别的错误，可以找到包 overtrue/easy-sms/src/Gateways  下面，因为我目前使用的 阿里云那么我的就是 AliyunGateway.php 找到 send 在 result 返回之前打印一下就可以看到错误。这里的错误也是阿里云服务错误，而不是程序的错误。</p>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年年度总结</title>
      <link href="/2020/01/14/2019%E5%B9%B4%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2020/01/14/2019%E5%B9%B4%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>回顾 2019 展望 2020，时间总是在转眼即逝！当我们站在时间线前面的时候，总是对时间线后面的所有事情抱有很大的期望与规划，或者这的 ‘我们’ 应该用 ‘我’ 比较合适！我特别喜欢一句话，做过别后悔，错过别回头！然而真实的我总是实在跟别人述说我的 “后悔的事情”，也许是心智未成熟吧，但是我还是喜欢有什么就说出来憋着难受！每过一段时间，我总是喜欢停下来整理一下所有前面的事情，写项目也是如此总是希望自己的代码能够达到心中理想的样子，但是事与愿违比较多那么一些，总体上来说还算及格。我也喜欢总是想把自己知识整理完善，但总是发现时间不够用（当然这也是自己说给自己的借口，时间挤挤还是有的 ）希望 2020 能自我改变一哈吧，实现自我的进化！</p><p><img src="https://i.loli.net/2020/01/15/QwPnoZreAbYaV7K.jpg" alt="timg.jpeg"></p><h3 id="宁波篇"><a href="#宁波篇" class="headerlink" title="宁波篇"></a>宁波篇</h3><p>19 年离开宁波公司回到成都，最开始我老汉和我妈特别不愿意。首先说一哈，我不是妈宝男，只是我从小就去的宁波读书生活，朋友亲戚基本都在宁波，一直跟着他们重来没有离开过他们，所以对于我不在去宁波跟他们一起特别不放心。最后我放出了终极大招他们才愿意我回来，我说回来后一定找到个女朋友，他们才愿意。（然而事实确是连个女的微信都没，在此我要强行甩一下锅，不是不想找是圈子太小没办法呀！）</p><p>希韵一个做钢琴教育类 App 软件开发的团队，一个非常不错的一个团队，公司的组织架构完整，团队气氛也是非常的好。以下是 2019 年年度团队动漫自画像。</p><p><img src="https://i.loli.net/2020/01/16/f45yHsDKAhJzRia.jpg" alt="img.jpeg"></p><p>我还依稀记得刚去面试，主管大哥很看好我，在面试完成后送我离开时跟我也分享了一些他的经历（可能公司基本都是宁波本地人，而他是贵州人而我是四川人的原因吧），可惜最后让他失望了。年轻嘛，总是有些时候犯混。也感谢当初辉哥和主管大哥选择了我，工作之后我问过辉哥为啥选我，我已经记不清他当时怎么说的了，我想估计是我的诚实吧。我入希韵时简历完全真实，没有任何参假，没工作经验，没项目经验，唯一有的是我离开学校那天起就一直从事计算机这块，转开发前就从事运维这块（当然是最低级的运维或者简单说修电脑的只是负责厂区）在现今的大环境下敢写真实的简历也是需要一定的勇气的，又没学历又没项目经验。</p><p>人生总是这样，生命当中总是会有那么几个站，你会在哪里停留，但是最终还是会重新扬帆启航！</p><p>告别了成长的第一站，我驶向了我的第二站，成都，成都篇启航！</p><p><img src="https://i.loli.net/2019/09/03/RWBTwtkD2MjPavh.jpg" alt></p><h3 id="成都篇-一"><a href="#成都篇-一" class="headerlink" title="成都篇 一"></a>成都篇 一</h3><p>四川玄通科技有限公司，面试我的是罗哥，应该算不上面试而是算讲解知识。没记错的话大概面试了一个多小时，很多问题不知道，罗哥跟大多数面试管不一样，不会因为你不会而有点别的样子(具体啥样子感觉就是有点看不起吧)，不知道或者认知错误的他都会一一的给你讲解。通过那一次面试我还学到了不少东西，影像最深的是他把 MySQL 索引这个东西给我讲解的大概明白了，以前基本都是模糊的认知。这样的面试才有意义，有收获！不像一些眼睛在天上的人上来就问（处理过千万级数据没有啊，高并发处理过吗）不怕您笑，现在做过三个项目别说千万级别了 10 W都没处理过。这样问的往往是那种几个人的公司，有时候真忍不住想问贵公司都这样牛逼了，团队咋这点人呢？没办法呀，本人眼界知识面太低，见笑见笑。</p><p>面试结束后，就说等待通知，我一想肯定没戏啊。回答的也不好，基本没了，就去下一家公司面试了。结果下一家公司给我气的呀，是个培训结构，为了约好的时间不迟到我还专门 打车过去的，结果是个培训机构。最后想了想压根没投递他们公司简历，我是手机收到短信就去了也没太注意，我好奇的是手机号码是如何被他们知道的，都是套路呀。</p><p>过了二天还是三天，收到了行政的通知可以入职玄通了。当时很高兴，因为这哈有大佬带了，特别高兴。</p><p>玄通呢，做的项目就是区块链的东西，说是区块链具体有没有上链我也没搞清楚，用的也就是火币的接口。从入职开始，有啥不懂的就问罗哥，反正他也不会烦你不懂问他，相反罗哥是一个特别喜欢帮助人的人，只要不懂的问他都会耐心的解答。从代码的语法，到一些东西使用和原理都会一一讲解，反正我非常喜欢跟着罗哥，成长快呀！</p><p>在玄通的日子每天就这样工作着，学习着，没事情的时候大家就一起吹吹壳子，开开车。好不欢乐！</p><p>可惜好景不长，在项目第二个版本开始的时候，8 月份的某一天清晨。老板先是把行政，罗哥和前端叫进办公室，我一哈就觉得不对了。因为那段时间罗哥一直挂嘴边的就是公司快倒闭了，结果真的倒闭了！！！他们先单独聊了后，老板叫所有人进去了，公司正式宣布倒闭！可气的是到现在还有一点工钱没给，搞得我没事给老板发几朵花。不舍玄通，无奈告别！开启第二篇章！</p><p><img src="https://i.loli.net/2020/01/16/s2EHUQRVcNAgMx1.jpg" alt="96c6035bd38a43c3bc532447a7292ee2.jpeg"></p><h3 id="成都篇-二"><a href="#成都篇-二" class="headerlink" title="成都篇 二"></a>成都篇 二</h3><p>我易网络科技有限公司，面试我的是公司负责项目的人。面试不算太久吧，好像 10 分钟的样子，也是等待通知。心想肯定没了，才那么几分钟。结果在我第二天去铂涛面试的路上收到了入职通知，面试铂涛是二个人一起面试，那次面试把我搞得紧张死了。大概面试了 30 多分钟吧，也是等待通知。面试完成后，就回家准备第二天入职我易了。</p><p>入职我易当天也收到了铂涛的入职邀请，出于已经入职我易和不会 YII 谢绝了铂涛正式开始了，我易的旅途。</p><p>我易跟玄通基本一样，也是做虚拟币交易的公司，也是没有上链都是自我数据处理（不过目前的是版本一，后期估计是会上链操作）。刚开始都是老套路，熟悉公司先目前的项目代码。前面基本也没什么事情，基本上都在原先的项目上面各种修改。其实我是拒绝二开的，比较每个人的风格不一，而且还需要去读懂原有的代码就更难受了。在修改过程中，我们也经常喷方维写的代码垃圾（结果自己写后发现自己的根本没法跟方维的比），终于在 11 月份，项目开始了重构。我们整个团队开启了奋战模式，几乎这几个月来每一天都在加班奋战赶项目。1月10号在连续奋战30多个小时后，第一个版本正式上线。虽然存在很多问题，但也正式上线了。到此三篇结束，2019 年的也即将结束。</p><p><img src="https://i.loli.net/2020/01/16/4dSzbiC5YmOa7jg.jpg" alt="center.jpeg"></p><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><p>1、PHP 深入学习</p><p>2、研究 Larave 框架</p><p>3、学习 Go</p><p>4、学习 Flutter</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、拖延症比较严重</p><p>2、执行能力，有待提高</p><p>3、心性有待提高</p><blockquote><p>祝愿 2020 更好，道别 2019 。2020 加油吧！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 2019年年度总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019年年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-XSS 攻击过滤</title>
      <link href="/2019/12/16/Laravel-Xss-%E6%94%BB%E5%87%BB%E8%BF%87%E6%BB%A4/"/>
      <url>/2019/12/16/Laravel-Xss-%E6%94%BB%E5%87%BB%E8%BF%87%E6%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>XSS 攻击，XSS 是跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。它总是让我们头痛，目前还不是很了解，毕竟前端的知识欠缺，看过一篇文章说“越了解 XSS 越不知道该如何去防范”。目前来说所认知的 XSS 就是前端的 JS 搞事情，那么好在数据处理时候我们过滤掉黑名单的前端标记。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://packagist.org/packages/mews/purifier" target="_blank" rel="noopener">mews/purifier</a></p><pre><code>composer require mews/purifier</code></pre><p>再次提示一次，在 Laravel 5.5 版本之后不需要在添加服务提供者，都是自动发现。</p><h3 id="发布配置"><a href="#发布配置" class="headerlink" title="发布配置"></a>发布配置</h3><pre><code>$ php artisan vendor:publish --provider=&quot;Mews\Purifier\PurifierServiceProvider&quot;</code></pre><p>此时 <code>config/purifier.php</code> 就会出现在你的 config 目录当中。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用 purifier 非常的简单</p><pre><code>clean(request()-&gt;input(&#39;content&#39;))</code></pre><p>注意：我们可以使用的标记在 <code>config/purifier.php</code> HTML.Allowed 配置当中</p><pre><code># 以下是默认的允许的标记&#39;HTML.Allowed&#39;             =&gt; &#39;div,b,strong,i,em,u,a[href|title],ul,ol,li,p[style],br,span[style],img[width|height|alt|src]&#39;,</code></pre><p>在我们使用 clean 过滤我们的参数之后，默认自动段落的也就是说数据会自动加上 “ P “  标记</p><p><img src="https://i.loli.net/2019/12/16/S1ZVk3yHJfFig9E.png" alt></p><p>如果不需要加上 “ P “  标记，那么我们需要把配置文件当中的 AutoFormat.AutoParagraph 改为 false</p><pre><code>&#39;AutoFormat.AutoParagraph&#39; =&gt; false,</code></pre><p><img src="https://i.loli.net/2019/12/16/bGkTYjigILOsC4d.png" alt></p><p>回到最开始，我们在 HTML.Allowed 允许的情况下，那么我们 HTML 标记就不会被过滤掉</p><p><img src="https://i.loli.net/2019/12/16/oK68RCm3THeYdAS.png" alt></p><h3 id="使用中间件全局过滤"><a href="#使用中间件全局过滤" class="headerlink" title="使用中间件全局过滤"></a>使用中间件全局过滤</h3><pre><code># 创建中间件php artisan make:middleware ApiXssCleanpublic function handle($request, Closure $next){    $input = $request-&gt;all();    array_walk_recursive($input,function(&amp;$input) {        $input = is_string($input) ? trim(clean($input)) : $input;    });    $request-&gt;merge($input);    return $next($request);}</code></pre><p><img src="https://i.loli.net/2019/12/16/QXW8ULvFlen7MOx.png" alt></p><h3 id="使用-PHP-函数-暴力过滤"><a href="#使用-PHP-函数-暴力过滤" class="headerlink" title="使用 PHP 函数 暴力过滤"></a>使用 PHP 函数 暴力过滤</h3><p>strip_tags — 从字符串中去除 HTML 和 PHP 标记</p><pre><code># 效果与上面一致$input = $request-&gt;all();array_walk_recursive($input,function(&amp;$input) {    $input = strip_tags($input);});$request-&gt;merge($input);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-Goog验证</title>
      <link href="/2019/11/18/Laravel-Goog%E9%AA%8C%E8%AF%81/"/>
      <url>/2019/11/18/Laravel-Goog%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>对于一些项目敏感操作来说验证用户都是属于必备的一个环节，当然验证的方式很多，确实很多！Google 验证，在我看来是验证当中的一种不错的选择，毕竟一次操作终身可行，而且 Google 自身就帮我们处理好了验证码有效期。（每30秒刷新一次），签名算法安全可靠！Laravel 做为 PHP 目前使用率最高的框架，当然也有他的 Google 验证扩展包。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://packagist.org/packages/pragmarx/" target="_blank" rel="noopener">pragmarx/</a>google2fa-laravel</p><pre><code># 扩展 Imagick 开启composer require pragmarx/google2fa-laravel</code></pre><p><a href="https://packagist.org/packages/bacon/" target="_blank" rel="noopener">bacon/</a>bacon-qr-code</p><pre><code># 扩展 iconv 开启# dasprid/enumcomposer require bacon/bacon-qr-code</code></pre><h4 id="安装-Imagick-扩展"><a href="#安装-Imagick-扩展" class="headerlink" title="安装 Imagick 扩展"></a>安装 Imagick 扩展</h4><pre><code>apt-get install imagemagickconvert -version 使用这个命令检测是否安装成功，如果成功的话会有imagemagick版本号。apt-get install libmagickwand-dev</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>生成 Google2FA 配置文件，文件存在位置 config/google2fa.php，命令如下：</p><pre><code>php artisan vendor:publish --provider=&quot;PragmaRX\Google2FALaravel\ServiceProvider&quot;</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>生成 Secret Key</p><pre><code>use PragmaRX\Google2FA\Google2FA;$google2fa = new Google2FA();$secretKey = $google2fa-&gt;generateSecretKey(64);# 这里的 Key 就是我们需要验证的 Key</code></pre><p>获取二维码地址</p><pre><code>$company = &#39;&#39;; // 公司名称$holder = &#39;&#39;; // 用户标示，可以是邮箱或者名称等$qrcodeUrl = $google2fa-&gt;getQRCodeUrl($company, $holder, $secretKey);</code></pre><p>生成二维码图片</p><pre><code>// 图片路径$filePath = sha1($secretKey) .&#39;.png&#39;;// 生成图片$renderer = new ImageRenderer(   new RendererStyle(200),   new ImagickImageBackEnd());$writer = new Writer($renderer);$writer-&gt;writeFile($qrcodeUrl, $filePath);</code></pre><p><img src="https://i.loli.net/2019/11/18/hTlsNIDrVp5qmFz.png" alt></p><p>最后，通过使用 Google Authenticator 应用程序来扫描二维码，扫描完毕之后，就会生成一组 6 位的数字密码。</p><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><pre><code>$google2fa = new Google2FA();$verify = $google2fa-&gt;verifyKey($secretKey, $request-&gt;input(&#39;code&#39;));if ($verify) {    return true;  // 验证成功}return false;</code></pre><blockquote><p>参考地址：</p><p><a href="https://www.raymondwu.net/2018/05/14/Laravel-利用Google2FA实现双因子认证/" target="_blank" rel="noopener">https://www.raymondwu.net/2018/05/14/Laravel-%E5%88%A9%E7%94%A8Google2FA%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%9B%A0%E5%AD%90%E8%AE%A4%E8%AF%81/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-RSA加密解密</title>
      <link href="/2019/11/14/PHP-RSA%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
      <url>/2019/11/14/PHP-RSA%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><blockquote><p>在目前的大环境下，我们一般的项目都是属于前后端分离的操作。数据安全就是让我们非常头痛的一件事情。</p></blockquote><h3 id="生成公钥私钥"><a href="#生成公钥私钥" class="headerlink" title="生成公钥私钥"></a>生成公钥私钥</h3><p>Linux 系统都自带了openssl，windows 可能需要安装 openssl 生成工具</p><pre><code>// 第一步：生成私钥，这里我们指定私钥的长度为1024, 长度越长，加解密消耗的时间越长openssl genrsa -out rsa_private_key.pem 1024// 第二步：根据私钥生成对应的公钥openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pub// 第三步：私钥转化成pkcs8格式，【这一步非必须，只是程序解析起来方便】openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt -out rsa_private_key_pkcs8.pem</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>RSA 只能加密最长 117 位的数据</p><pre><code>$data = &#39;123&#39;;$data = json_encode($data);$Split = str_split($data, 64);ForEach($Split as $Part){    openssl_private_encrypt($Part,$PartialData,$privateKey);//服务器公钥加密    $t = strlen($PartialData);    $encParam_encrypted .= $PartialData;}$data = base64_encode($encParam_encrypted);</code></pre>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-定时任务</title>
      <link href="/2019/10/24/Laravel-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2019/10/24/Laravel-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>在我们项目当中，有时候需要定时去处理一些特定的业务。过去，你可能需要在服务器上为每一个调度任务去创建 Cron 入口。但是这种方式很快会变得不友好，因为这些任务调度不在源代码中，并且你每次都需要通过 SSH 链接登录到服务器中才能增加 Cron 入口。</p><p>Laravel 命令行调度器允许你在 Laravel 中对命令调度进行清晰流畅的定义。且使用这个任务调度器时，你只需要在你的服务器上创建单个 Cron 入口。你的任务调度在 <code>app/Console/Kernel.php</code> 的 <code>schedule</code> 方法中进行定义。</p><h3 id="Kernel-php"><a href="#Kernel-php" class="headerlink" title="Kernel.php"></a>Kernel.php</h3><p>不管我们是使用定时任务或者其他需要终端执行的程序，在 Laravel 当中都要在 <code>app\console\kernel.php</code>当中的 commands 引入我们自定义的 artisan 命令类，schedule 执行我们的定时任务。</p><pre><code># 加载 artisan 自定义命令类protected $commands = [        // 引入自定义的终端命令类    ];    # 执行 定时任务    protected function schedule(Schedule $schedule){    # 简单使用    $schedule-&gt;call(function(){        Log::info(&#39;记录的日志&#39;,[&#39;ip&#39; =&gt; request()-&gt;path()]);    })-&gt;daily();    $schedule-&gt;call(&#39;App\Services\xxxService@index&#39;)-&gt;everyMinute();    # 执行 command    $schedule-&gt;command(&#39;order:start&#39;)              -&gt;hourly();}# 注册 artisan 执行的命令，对应的也就是我们 routes 下面的 console.phpprotected function commands(){    $this-&gt;load(__DIR__.&#39;/Commands&#39;);    require base_path(&#39;routes/console.php&#39;);}</code></pre><blockquote><p>在 Laravel 5.5 版本以后，无需在 commands 引入。</p></blockquote><h3 id="创建-Command"><a href="#创建-Command" class="headerlink" title="创建 Command"></a>创建 Command</h3><pre><code>php artisan make:command AddOrderCount</code></pre><p>当创建完成 command 之后，按自己需求修改 command</p><pre><code>class OrderCount extends Command{    // 执行的 artisan 命令    protected $signature = &#39;order:start&#39;;    // artisan 命令的描述    protected $description = &#39;day order count data&#39;;    public function __construct()    {        parent::__construct();    }    // 这里即可执行 业务逻辑的处理    public function handle()    {        // 要执行的 处理业务逻辑    }}</code></pre><h3 id="执行-Crontab"><a href="#执行-Crontab" class="headerlink" title="执行 Crontab"></a>执行 Crontab</h3><pre><code>1、创建 crontab 执行的文件echo &quot;* * * * * /usr/local/bin/php /var/www/html/vpay/artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1&quot; &gt; order.txt2、添加到 crontab 当中crontab order.txt3、开启 crontabcrontabl -l 4、关闭 crontab 全部清除crontabl -r</code></pre><blockquote><p>在 Linux 创建一个 Crontab 执行文件时，所有的执行命令加上绝对路径！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-本地语言包</title>
      <link href="/2019/10/11/Laravel-%E6%9C%AC%E5%9C%B0%E8%AF%AD%E8%A8%80%E5%8C%85/"/>
      <url>/2019/10/11/Laravel-%E6%9C%AC%E5%9C%B0%E8%AF%AD%E8%A8%80%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Laravel 自身的语言包为英文，我们本地化开发都希望为中文，当然也有不需要中文的这个看自己项目的选择行来说，我做的项目一般都是本地化。所以本地化是不可缺少的一块。今天的主角就是 [<a href="https://packagist.org/packages/caouecs/" target="_blank" rel="noopener">caouecs/</a><a href="https://packagist.org/packages/caouecs/laravel-lang#dev-master" target="_blank" rel="noopener">laravel-lang</a>] ,支持 N 多国家语言包。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>$ composer require caouecs/laravel-lang</code></pre><blockquote><p>请根据自己项目使用的 Laravel 版本选择分支，不同的分支对应 Laravel 不同的版本。</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>laravel-lang 使用非常简单，在我们 Composer 安装好这个扩展包以后，在 verdor 依赖包目录当中找到 <code>caouecs/laravel-lang</code>把里面的 zh-CN 复制到 <code>resources/lang</code>下面。修改 <code>config/app.php</code></p><pre><code>&#39;locale&#39; =&gt; &#39;zh-CN&#39;,</code></pre><p>到此完成了 Laravel 语言包的替换，现在使用就是本地化了（如：表单验证），当然有无法替换的地方可以自行去修改语言包。</p>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-Fractal</title>
      <link href="/2019/09/26/Laravel-Fractal/"/>
      <url>/2019/09/26/Laravel-Fractal/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>我们想返回的数据做格式化一般情况下我们就在逻辑层当中操作，这样复用性很差基本就是复制粘贴。使用了  Fractal 之后我们就可以统一一些数据返回的规范，复用性非常高。</p><p><img src="https://i.loli.net/2019/09/26/Dy7bAWSHLeExzot.png" alt></p><p><strong>PHP 领域广受欢迎的 API 数据输出格式转换器</strong></p><ul><li>支持 <code>单个对象</code> 或者 <code>集合对象</code> 的格式化</li><li>通过 Fractal Transformer 显式修饰对象的数据输出，将复杂数据转为 ajax/restful</li><li>额外特性<ul><li>关联数据的<code>Include</code>动态加载</li><li>数据载荷转换到各种协议格式：<code>JSON</code>、<code>DataArray</code>、<code>HAL</code>等等</li></ul></li><li>友好的和<code>DingoApi</code>无缝结合</li></ul><p><strong>对于 WEB 站来说</strong></p><ul><li>不建议过多进行数据格式化，直接输出完整对象，尽量用对象来替代数组</li><li>特别的字段值计算可以封装为对象的方法</li></ul><h3 id="原生使用"><a href="#原生使用" class="headerlink" title="原生使用"></a><strong>原生使用</strong></h3><pre><code>class MyTransformer extends League\Fractal\TransformerAbstract{    # normalize主逻辑    public function transform($object){        return [            &#39;id&#39; =&gt; $object-&gt;id,            &#39;name&#39; =&gt; $object-&gt;name,        ];    }    ## include特性 ##    ## 使用前需要检测include参数：$manager-&gt;parseIncludes($_GET[&#39;include&#39;]);    protected $defaultIncludes = []; #声明需要默认include的资源    protected $availableIncludes = [tag]; #声明可选include资源    public function includeTag($object){        $tag = $object-&gt;tag;        return $this-&gt;item($tag, new TagTransformer);  #包含单对象        #return $this-&gt;collection($tags, new TagTransformer); #包含集合对象    }}$itemResource = new \Fractal\Resource\Item(    $object,    League\Fractal\TransformerAbstract $myTransformer);$collectionResource = new \Fractal\Resource\Collection(    $objects,    League\Fractal\TransformerAbstract $myTransformer);$manager = new League\Fractal\Manager();$manager = $manager-&gt;createData($itemResource|$collectionResource)-&gt;toArray|toJson(); #transformer转换数据# 可以进一步使用serializer在toArray()输出前调整数据结构</code></pre><h3 id="Laravel-下-Fractal-使用"><a href="#Laravel-下-Fractal-使用" class="headerlink" title="Laravel 下 Fractal 使用"></a>Laravel 下 Fractal 使用</h3><p>1、Composer 引入</p><pre><code>composer require league/fractal</code></pre><p>2、创建自定义数据处理文件</p><pre><code>&lt;?phpnamespace App\Http\DataResponse;use App\Http\Model\User;use League\Fractal\TransformerAbstract;class UserDataResponse extends TransformerAbstract{   public function transform(User $user)   {       return [           &#39;id&#39; =&gt; $user-&gt;id,           &#39;mobile&#39; =&gt; $user-&gt;mobile,           &#39;nickname&#39; =&gt; $user-&gt;nickname,           &#39;avatar&#39; =&gt; $user-&gt;avatar,           &#39;updated_at&#39; =&gt; (string)$user-&gt;updated_at,           &#39;created_at&#39; =&gt; (string)$user-&gt;created_at,       ];   }}</code></pre><p>3、集合对象序列化</p><pre><code> # 需要 use  use App\Http\DataResponse\UserDataResponse; use League\Fractal\Manager; use League\Fractal\Resource\Collection; # 正常使用 $fractal = new Manager(); $users = new collection(User::all(), new UserDataResponse()); $users = $fractal-&gt;createData($users)-&gt;toArray(); return $users;</code></pre><p>4、单个对象序列化</p><pre><code> # 需要 use  use App\Http\DataResponse\UserDataResponse; use League\Fractal\Manager; use League\Fractal\Resource\Item; # 正常使用 $fractal = new Manager(); $users = new Item(auth()-&gt;user(), new UserDataResponse()); $users = $fractal-&gt;createData($users)-&gt;toArray(); return $users;</code></pre><blockquote><p>参考地址：</p><p><a href="https://my.oschina.net/u/2400083/blog/988715" target="_blank" rel="noopener">https://my.oschina.net/u/2400083/blog/988715</a></p><p><a href="https://zhuanlan.zhihu.com/p/25554084" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25554084</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-JWT</title>
      <link href="/2019/09/18/Laravel-JWT/"/>
      <url>/2019/09/18/Laravel-JWT/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><blockquote><p><a href="https://jwt.io/" target="_blank" rel="noopener">JWT</a> 是 JSON Web Token 的缩写，是一个非常轻巧的规范，这个规范允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息。</p></blockquote><p>JWT 由头部（header）、载荷（payload）与签名（signature）组成，一个 JWT 类似下面这样：</p><pre class="line-numbers language-‘"><code class="language-‘">{    "typ":"JWT",    "alg":"HS256"}{    "iss":"http://larabbs.test",签发人    "iat":1515733500,签发时间    "exp":1515737100,过期时间    "nbf":1515733500,生效时间，在此之前是无效的    "jti":"c3U4VevxG2ZA1qhT",编号    "sub":1,主题    "prv":"23bd5c8949f600adb39e701c400872db7a5976f7"}signature<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>头部申明了加密算法；</li><li>载荷中有两个比较重要的数据，<code>exp</code> 是过期时间，<code>sub</code> 是 JWT 的主体，<strong>这里就是用户的 id</strong>；</li><li>最后的 signature 是由服务器进行的签名，保证了 token 不被篡改。</li></ul><p>用户 id，过期时间等数据都保存在 Token 中了，所以并不需要将 Token 保存在服务器中，客户端请求的时候在 Header 中携带 Token，服务器获取 Token 后，进行 <code>base64_decode</code> 即可获取数据进行校验，由于已经有了签名，所以不用担心数据被篡改。</p><p><strong>加密 Token 解密</strong></p><p><img src="https://i.loli.net/2019/11/17/jXCUve2W8xqMGpO.png" alt></p><blockquote><p>JWT 最后是通过 Base64 编码的，也就是说，它可以被翻译回原来的样子来的。所以不要在 JWT 中存放一些敏感信息。</p></blockquote><h3 id="安装-jwt-auth"><a href="#安装-jwt-auth" class="headerlink" title="安装 jwt-auth"></a>安装 jwt-auth</h3><pre><code>$ composer require tymon/jwt-auth</code></pre><p>安装完成后，我们需要设置一下 JWT 的 secret，这个 secret 很重要，用于最后的签名，更换这个 secret 会导致之前生成的所有 token 无效。</p><pre><code>$ php artisan jwt:secret</code></pre><p>可以看到在 .env 文件中，增加了一行 <code>JWT_SECRET</code>。</p><p><strong>Laravel 5.5 版本以上不需要在添加服务提供者。</strong></p><h3 id="发布配置"><a href="#发布配置" class="headerlink" title="发布配置"></a>发布配置</h3><pre><code>php artisan vendor:publish --provider=&quot;Tymon\JWTAuth\Providers\LaravelServiceProvider&quot;</code></pre><p>您现在应该有一个<code>config/jwt.php</code>文件，允许您配置此程序包的基础知识。</p><p>修改 <code>config/auth.php</code>，将 <code>api guard</code> 的 <code>driver</code> 改为 <code>jwt</code>。</p><p><em>config/auth.php</em></p><pre><code>&#39;guards&#39; =&gt; [    &#39;web&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;session&#39;,        &#39;provider&#39; =&gt; &#39;users&#39;,    ],    &#39;api&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;jwt&#39;,        &#39;provider&#39; =&gt; &#39;users&#39;,    ],],# 注意一下模型的服务提供者，默认使用的 app\user &#39;providers&#39; =&gt; [    &#39;users&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;eloquent&#39;,        &#39;model&#39; =&gt; App\Http\Model\User::class,    ],</code></pre><p>如果使用了 Dingo API 修改 <code>config/api.php</code>，auth 中增加 JWT 相关的配置</p><p><em>config/api.php</em></p><pre><code>&#39;auth&#39; =&gt; [    &#39;jwt&#39; =&gt; &#39;Dingo\Api\Auth\Provider\JWT&#39;,],</code></pre><p>user 模型需要继承 <code>Tymon\JWTAuth\Contracts\JWTSubject</code> 接口，并实现接口的两个方法 getJWTIdentifier () 和 getJWTCustomClaims ()。</p><p><em>app\Models\User.php</em></p><pre><code>&lt;?phpnamespace App\Models;use Tymon\JWTAuth\Contracts\JWTSubject;use Illuminate\Notifications\Notifiable;use Illuminate\Foundation\Auth\User as Authenticatable;class User extends Authenticatable implements JWTSubject{    use Notifiable;    public function getJWTIdentifier()    {        return $this-&gt;getKey();    }    public function getJWTCustomClaims()    {        return [];    }}</code></pre><p>getJWTIdentifier 返回了 User 的 id，getJWTCustomClaims 是我们需要额外再 JWT 载荷中增加的自定义内容，这里返回空数组。</p><p><code>jwt-auth</code> 有两个重要的参数，可以在 <code>config/jwt.php</code> 中进行设置</p><ul><li>JWT_TTL 生成的 token 在多少分钟后过期，默认 60 分钟</li><li>JWT_REFRESH_TTL 生成的 token，在多少分钟内，可以刷新获取一个新 token，默认 20160 分钟，14 天。</li></ul><p>这里需要理解一下 JWT 的过期和刷新机制，过期很好理解，超过了这个时间，token 就无效了。刷新时间一般比过期时间长，只要在这个刷新时间内，即使 token 过期了， 依然可以换取一个新的 token，以达到应用长期可用，不需要重新登录的目的。</p><h3 id="助手函数"><a href="#助手函数" class="headerlink" title="助手函数"></a>助手函数</h3><pre><code>// 尝试通过某些凭据对用户进行身份验证$token = auth()-&gt;attempt($request);// 获取当前经过身份验证的用户。$result = auth()-&gt;user();// 注销用户-这将使当前令牌无效并取消验证用户的身份auth()-&gt;logout(); Token 可以继续使用直到 exp 过期auth()-&gt;logout(true);  马上把当前的 Token 永久性的加入黑名单// 刷新令牌，这会使当前令牌无效auth()-&gt;resfresh();auth()-&gt;resfresh(true,true); 将 true 作为第一个参数传递，以强制将令牌永久性列入黑名单。第二个参数将重置新令牌的声明// 使令牌无效（将其添加到黑名单）auth()-&gt;invalidate();auth()-&gt;invalidate(true); 马上把当前的 Token 永久性的加入黑名单// 判断当前用户是否登录auth()-&gt;check();</code></pre><h3 id="多用户验证"><a href="#多用户验证" class="headerlink" title="多用户验证"></a>多用户验证</h3><p>1、创建 Admin 模型，其他操作与 User 一致</p><pre><code>php artisan make:model Admin</code></pre><p>2、修改<code>config\auth.php</code>配置</p><pre><code> &#39;guards&#39; =&gt; [        &#39;admin&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;jwt&#39;,            &#39;provider&#39; =&gt; &#39;admins&#39;,        ],        &#39;api&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;jwt&#39;,            &#39;provider&#39; =&gt; &#39;users&#39;,            &#39;hash&#39; =&gt; false,        ],    ], &#39;providers&#39; =&gt; [        &#39;users&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;eloquent&#39;,            &#39;model&#39; =&gt; App\Http\Model\User::class,        ],        &#39;admins&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;eloquent&#39;,            &#39;model&#39; =&gt; App\Http\Model\Admin::class,        ],    ],    </code></pre><blockquote><p>JWT 超级详细的讲解博文：<a href="https://learnku.com/articles/10885/full-use-of-jwt#d08bfb" target="_blank" rel="noopener">https://learnku.com/articles/10885/full-use-of-jwt#d08bfb</a></p><p>JWT 官方使用手册：<a href="https://jwt-auth.readthedocs.io/en/develop/" target="_blank" rel="noopener">https://jwt-auth.readthedocs.io/en/develop/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-第三方登录</title>
      <link href="/2019/09/09/Laravel-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/"/>
      <url>/2019/09/09/Laravel-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>所谓的第三方登录，就是利用用户在第三方平台上已有的账号来快速完成自己应用的登录或者注册的功能，常用的协议为 OAuth 2.0，基本上每个 APP，都会集成微信，微博等第三方登录，方便用户快速的登录并开始使用。当然需要看一下 <a href>Socialite 社会化登录</a>能更好的使用第三方包。</p><h3 id="微信登录"><a href="#微信登录" class="headerlink" title="微信登录"></a>微信登录</h3><p>登录登录的流程图：</p><p><img src="https://i.loli.net/2019/09/12/DkGyJ3gdxB8r7vC.png" alt></p><h4 id="1、获取临时票据-CODE"><a href="#1、获取临时票据-CODE" class="headerlink" title="1、获取临时票据 CODE"></a>1、获取临时票据 CODE</h4><pre><code>https://open.weixin.qq.com/connect/oauth2/authorize?appid=自己的APPID&amp;redirect_uri=自己的网址&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirect</code></pre><p><img src="https://i.loli.net/2019/09/12/coS8U54QW6FBkn7.png" alt></p><h4 id="2、获取-access-token-与-open-id"><a href="#2、获取-access-token-与-open-id" class="headerlink" title="2、获取 access_token 与 open_id"></a>2、获取 access_token 与 open_id</h4><pre><code>https://api.weixin.qq.com/sns/oauth2/access_token?appid=自己的APPID&amp;secret=自己的AppSecret&amp;code=获取的CODE&amp;grant_type=authorization_code</code></pre><p><img src="https://i.loli.net/2019/09/12/vMzCp2Nq5BDiX6k.png" alt></p><h4 id="3、获取个人信息"><a href="#3、获取个人信息" class="headerlink" title="3、获取个人信息"></a>3、获取个人信息</h4><pre><code>https://api.weixin.qq.com/sns/userinfo?access_token=自己的access_token&amp;openid=OPENID&amp;lang=zh_CN</code></pre><pre><code>{    &quot;openid&quot;: &quot;xxxxxxxxxxx&quot;,    &quot;nickname&quot;: &quot;哪吒大战假老练&quot;,    &quot;sex&quot;: 1,    &quot;language&quot;: &quot;zh_CN&quot;,    &quot;city&quot;: &quot;资阳&quot;,    &quot;province&quot;: &quot;四川&quot;,    &quot;country&quot;: &quot;中国&quot;,    &quot;headimgurl&quot;: &quot;&quot;,    &quot;privilege&quot;: []}</code></pre><h3 id="扩展包"><a href="#扩展包" class="headerlink" title="扩展包"></a>扩展包</h3><p><a href="https://socialiteproviders.netlify.com/" target="_blank" rel="noopener">Socialite Providers</a> 超级多的第三方开箱就用包。只要使用的 OAuth 2.0 协议的第三方登录，都可以用同样的方法去实现登录。</p><h4 id="1、install"><a href="#1、install" class="headerlink" title="1、install"></a>1、install</h4><pre><code>$ composer require socialiteproviders/weixin</code></pre><p>Laravel 5.5 版本以上不需要在<code>confi/app.php</code>添加服务提供者，Laravel 会自动发现包</p><h4 id="2、事件监听器"><a href="#2、事件监听器" class="headerlink" title="2、事件监听器"></a>2、事件监听器</h4><p>在<code>app/Providers/EventServiceProvider</code>当中的 <code>listen[]</code>添加</p><pre><code>/** * The event handler mappings for the application. * * @var array */protected $listen = [    \SocialiteProviders\Manager\SocialiteWasCalled::class =&gt; [        // add your listeners (aka providers) here        &#39;SocialiteProviders\\Weixin\\WeixinExtendSocialite@handle&#39;,    ],];</code></pre><h4 id="3、配置设置"><a href="#3、配置设置" class="headerlink" title="3、配置设置"></a>3、配置设置</h4><p>添加到<code>config/services.php</code></p><pre><code>&#39;weixin&#39; =&gt; [    &#39;client_id&#39; =&gt; env(&#39;WEIXIN_KEY&#39;),    &#39;client_secret&#39; =&gt; env(&#39;WEIXIN_SECRET&#39;),    &#39;redirect&#39; =&gt; env(&#39;WEIXIN_REDIRECT_URI&#39;)],</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code>$user = Socialite::driver(&#39;Weixin&#39;)-&gt;user();$accessTokenResponseBody = $user-&gt;accessTokenResponseBody;</code></pre><p>简单的使用</p><pre><code>        # 加载驱动        $driver = Socialite::driver($type);        if ($request-&gt;code)        {            # 获得 access_token 和 open_id            $token = $driver-&gt;getAccessTokenResponse($request-&gt;code)[&#39;access_token&#39;];        }else{            $token = $request-&gt;access_token;            # 设置 open_id            $driver-&gt;setOpenId($request-&gt;open_id);        }        # 获取用户信息        $result = $driver-&gt;userFromToken($token);        # 获取 unionid 只有在用户将公众号绑定到微信开放平台帐号后，才会出现 unionid 字段        $unionid = $result-&gt;offsetExists(&#39;unionid&#39;) ? $result-&gt;offsetGet(&#39;unionid&#39;) : null;</code></pre><p>核心源码在于<code>vendor/socialiteproviders/weixin/Provider.php</code></p>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-DingoApi</title>
      <link href="/2019/09/08/Laravel-DingoApi/"/>
      <url>/2019/09/08/Laravel-DingoApi/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p><a href="https://github.com/dingo/api/" target="_blank" rel="noopener">dingo/api</a> 是一个 Lumen 和 Laravel 都可用的 RestFul 工具包，帮助我们快速的开始构建 RestFul Api。我们的目的是教会大家如何快速的搭建并使用这个包，更多的功能，还需要你仔细阅读 DingoApi 的 <a href="https://github.com/dingo/api/wiki" target="_blank" rel="noopener">文档</a> 来深入的学习和理解，<a href="https://github.com/liyu001989/dingo-api-wiki-zh" target="_blank" rel="noopener">这里</a>有一份中英对照的翻译，或许能帮到你。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>$ composer require dingo/api</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>先将 dingo 的配置文件发布出来</p><pre><code>$ php artisan vendor:publish --provider=&quot;Dingo\Api\Provider\LaravelServiceProvider&quot;</code></pre><p>执行成功后，我们会在 <code>config</code> 目录先看到 <code>api.php</code> 文件，打开文件我们可以看到所有的配置都是可以在 <code>.env</code> 中修改，下面我们主要讲解一下我们需要用到的配置。</p><p>1、API_STANDARDS_TREE 有是三个值可选</p><ul><li><code>x</code> 本地开发的或私有环境的</li><li><code>prs</code> 未对外发布的，提供给公司 app，单页应用，桌面应用等</li><li><code>vnd</code> 对外发布的，开放给所有用户</li></ul><pre><code>API_STANDARDS_TREE=prs</code></pre><p>2、API_SUBTYPE 一般情况下是我们项目的简称</p><pre><code>API_SUBTYPE=make</code></pre><p>3、API_PREFIX 和 API_DOMAIN<br>对于一个项目，通过前缀或者子域名的方式来区分开 API 与 Web 等页面访问地址是十分有必要的。假如正式上线的项目地址为 <code>www.make.com</code>，我们可以为 API 添加一个前缀</p><pre><code>API_PREFIX=api</code></pre><p>通过 <code>www.make.com/api</code> 来访问 API。<br>或者有可能单独配置一个子域名 <code>api.make.com</code></p><pre><code>API_DOMAIN=api.make.com</code></pre><p>通过 api.make.com 来访问 API。</p><p>特别要注意的是：<strong>前缀和子域名，两者有且只有一个</strong></p><p>4、API_VERSION<br>默认的 API 版本，当我们没有传 <code>Accept</code> 头的时候，默认访问该版本的 API。一般情况下配置 v1 即可。</p><pre><code>API_VERSION=v1# 请求头当中添加，选择版本Accept Accept: application/prs.make.v1+jsonAccept Accept: application/prs.make.v2+json</code></pre><p>5、API_STRICT<br>是否开启严格模式，如果开启，则必须使用 <code>Accept</code> 头才可以访问 API，也就是说直接通过浏览器，访问某个 GET 调用的接口，如 <code>https://api.larabbs.com/users</code>，将会报错。必须使用 Postman 之类的调试工具，设置 <code>Accept</code> 后才可访问。可以根据需求开启，默认情况下为 false。</p><p>6、API_DEBUG<br>测试环境，打开 debug，方便我们看到错误信息，定位错误。<br>最后我们的配置如下</p><pre><code>API_DEBUG=true</code></pre><p>7、配置 <code>.env</code></p><pre><code>API_STANDARDS_TREE=prsAPI_SUBTYPE=makeAPI_DOMAIN=api.make.comAPI_VERSION=v1API_DEBUG=true</code></pre><p>8、使用 dingo</p><pre><code># 依然是在 route/api.php 当中使用$api = app(&#39;Dingo\Api\Routing\Router&#39;);$api-&gt;version(&#39;v1&#39;, function($api) {    $api-&gt;get(&#39;version&#39;, function() {        return view(&#39;welcome&#39;);    });});$api-&gt;version(&#39;v2&#39;, function($api) {    $api-&gt;get(&#39;version&#39;, function() {        return response(&#39;this is version v2&#39;);    });});# 创建一个 Controller 类&lt;?phpnamespace App\Http\Controllers\v1;use Illuminate\Http\Request;use App\Http\Controllers\Controller as BaseController;use Dingo\Api\Routing\Helpers;class Controller extends BaseController{    use Helpers;}</code></pre><blockquote><p>注意如果是有 laravel-debugbar 那么就需要在 config/debugbar.php 把配置修改以下</p></blockquote><pre><code>&#39;enabled&#39; =&gt; env(&#39;APP_DEBUG&#39;, false)# 修改为&#39;enabled&#39; =&gt; env(&#39;DEBUGBAR_ENABLE&#39;, false)# 如果需要就在 .env 当中开启DEBUGBAR_ENABLE=true</code></pre><blockquote><p>提示：由于路由被 DingoApi 接管了，如果将来部署上线后你需要缓存路由，可以使用 <code>php artisan api:cache</code> 代替 <code>php artisan route:cache</code> ，本地测试请<strong>不要执行这个命令</strong>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-日志操作</title>
      <link href="/2019/09/07/Laravel-%E6%97%A5%E5%BF%97%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/09/07/Laravel-%E6%97%A5%E5%BF%97%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>为了帮助你更多的了解应用程序中到底发生了什么，Laravel 提供了强大的日志服务，允许你将日志消息、系统错误日志记录到文件，甚至使用 Slack 通知到你的整个团队。</p><p>在 Laravel 框架中，Laravel 使用 <a href="https://github.com/Seldaek/monolog" target="_blank" rel="noopener">Monolog</a> 库，它为各种强大的日志处理提供支持。Laravel 使配置这些处理程序变得简单，允许你混合并匹配它们自定义的应用程序日志处理。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>所有的应用程序日志系统配置都位于 <code>config/logging.php</code> 配置文件中。默认使用大概配置如下：</p><pre><code># 默认使用的 stack 通道&#39;default&#39; =&gt; env(&#39;LOG_CHANNEL&#39;, &#39;stack&#39;),# 注意真正在使用的是 .env 文件当中的 LOG_CHANNEL=stack，修改这里即可修改默认通道&#39;channels&#39; =&gt; [         # 默认使用的通道        &#39;stack&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;stack&#39;,# 驱动            &#39;channels&#39; =&gt; [&#39;daily&#39;], # 聚合，支持多通道            &#39;ignore_exceptions&#39; =&gt; false, # 默认忽略异常        ],         # stack 又聚合了 daily 通道，它每天的日志信息都会输出到 storage/log 文件下        &#39;daily&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;daily&#39;, # 驱动            &#39;path&#39; =&gt; storage_path(&#39;logs/laravel.log&#39;),# 日志文件存储路径            &#39;level&#39; =&gt; &#39;debug&#39;, # 八大错误级别            &#39;days&#39; =&gt; 14, # 日志分片周期，多少天一个文件        ],    ]</code></pre><h3 id="配置-Single-和-Daily-通道"><a href="#配置-Single-和-Daily-通道" class="headerlink" title="配置 Single 和 Daily 通道"></a>配置 Single 和 Daily 通道</h3><p><code>single</code> 和 <code>daily</code> 通道包含三个可选配置项：<code>bubble</code> 、<code>permission</code> 和 <code>locking</code></p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>名称</td><td>描述</td><td>默认值</td></tr><tr><td><code>bubble</code></td><td>消息处理后，指示消息是否推送到其他通道</td><td><code>true</code></td></tr><tr><td><code>permission</code></td><td>日志文件权限</td><td><code>0644</code></td></tr><tr><td><code>locking</code></td><td>写入之前尝试锁定日志文件</td><td></td></tr></tbody></table><h3 id="日志写入的八大级别"><a href="#日志写入的八大级别" class="headerlink" title="日志写入的八大级别"></a>日志写入的八大级别</h3><table><thead><tr><th align="left">错误等级</th><th align="left">描述</th><th align="left">整型值</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="left">debug</td><td align="left">代码引用为 “MonologLogger::DEBUG”</td><td align="left">100</td><td align="left">紧急，如系统挂掉</td></tr><tr><td align="left">info</td><td align="left">代码引用为 “MonologLogger::INFO”</td><td align="left">200</td><td align="left">需要立即采取行动，如数据库异常等</td></tr><tr><td align="left">notice</td><td align="left">代码引用为 “MonologLogger::NOTICE”</td><td align="left">250</td><td align="left">严重问题，如异常</td></tr><tr><td align="left">warning</td><td align="left">代码引用为 “MonologLogger::WARNING”</td><td align="left">300</td><td align="left">运行时错误，不需要立即处理但需要被记录和监控</td></tr><tr><td align="left">error</td><td align="left">代码引用为 “MonologLogger::ERROR”</td><td align="left">400</td><td align="left">警告但不是错误，比如使用了被废弃的API</td></tr><tr><td align="left">critical</td><td align="left">代码引用为 “MonologLogger::CRITICAL”</td><td align="left">500</td><td align="left">普通但值得注意的事件</td></tr><tr><td align="left">alert</td><td align="left">代码引用为 “MonologLogger::ALERT”</td><td align="left">550</td><td align="left">感兴趣的事件，比如登录、退出</td></tr><tr><td align="left">emergency</td><td align="left">代码引用为 “MonologLogger::EMERGENCY”</td><td align="left">600</td><td align="left">详细的调试信息</td></tr></tbody></table><h3 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h3><pre><code>&lt;?phpnamespace App\Http\Controllers;use Illuminate\Http\Request;# 引入 Loguse Illuminate\Support\Facades\Log;class UsersController extends Controller{    public function get()    {        # 写入日志，第二次参数为数组在日志文件当中转换为 JSON 默认使用配置文件中默认的通道        Log::info(&#39;记录的日志&#39;,[&#39;ip&#39; =&gt; \request()-&gt;ip()]);        # 以上是写入默认配置文件当中的通道，除此之外还可以指定写入的通道        Log::channel(&#39;single&#39;)-&gt;info(&#39;记录的日志&#39;,[&#39;ip&#39; =&gt; \request()-&gt;ip()]);        # 如果想要创建一个由多通道构成的按需记录的堆栈，可以使用 stack 方法：        Log::stack([&#39;single&#39;, &#39;slack&#39;])-&gt;info(&#39;Something happened!&#39;);    }}</code></pre><p>日志文件的结果：</p><pre><code># 注意虽然他们在日志文件里面的结果都是一样，但是他们存储的日志文件是不一样的一个单一、一个日常[2019-09-07 13:58:05] local.INFO: 记录的日志 {&quot;ip&quot;:&quot;xxxxxxxxxxx&quot;} </code></pre><h3 id="自定义-Monolog-通道"><a href="#自定义-Monolog-通道" class="headerlink" title="自定义 Monolog 通道"></a>自定义 Monolog 通道</h3><p>首先我们需要在<code>config/logging.php</code>中添加一个 tap 数组。</p><pre><code># 自定义 monolog 通道&#39;monolog&#39; =&gt; [    &#39;driver&#39; =&gt; &#39;daily&#39;, # 使用的 daily 每日记录    &#39;tap&#39; =&gt; [App\Logging\CustomizeFormatter::class],# 接口    &#39;permission&#39;=&gt; 0777, # 权限    &#39;path&#39; =&gt; storage_path(&#39;logs/laravel.log&#39;), # 存储的路径    &#39;level&#39; =&gt; &#39;debug&#39;, # 八大错误级别    &#39;days&#39; =&gt; 1, # 日志分片],</code></pre><p>创建 CustomizeFormatter.php</p><pre><code>&lt;?phpnamespace App\Logging;# 引入自定义的 Formatteruse App\Logging\JsonFormatter;class CustomizeFormatter{    /**     * 自定义给定的日志实例。     *     * @param  \Illuminate\Log\Logger  $logger     * @return void     */    public function __invoke($logger)    {        foreach ($logger-&gt;getHandlers() as $handler) {            $handler-&gt;setFormatter(new JsonFormatter());        }    }}</code></pre><p>创建 JsonFormatter.php</p><pre><code>&lt;?phpnamespace App\Logging;use Monolog\Formatter\JsonFormatter as BaseJsonFormatter;class JsonFormatter extends BaseJsonFormatter{    public function format(array $record) ：string　    {        // 这个就是最终要记录的数组，最后转成Json并记录进日志        $newRecord = [            &#39;time&#39; =&gt; $record[&#39;datetime&#39;]-&gt;format(&#39;Y-m-d H:i:s&#39;),            &#39;message&#39; =&gt; $record[&#39;message&#39;],        ];        if (!empty($record[&#39;context&#39;])) {            $newRecord = array_merge($newRecord, $record[&#39;context&#39;]);        }        //$json = &#39;aaa,bbb,ccc&#39;;  // 这是最终返回的记录串，可以按自己的需求改        $json = $this-&gt;toJson($this-&gt;normalize($newRecord), true) . ($this-&gt;appendNewline ? &quot;\n&quot; : &#39;&#39;);        return $json;    }}</code></pre><p>使用自定义的通道</p><pre><code>Log::channel(&#39;monolog&#39;)-&gt;info(&#39;记录的日志&#39;,[&#39;ip&#39; =&gt; \request()-&gt;ip()]);# 结果{&quot;time&quot;:&quot;2019-09-07 16:37:52&quot;,&quot;message&quot;:&quot;记录的日志&quot;,&quot;ip&quot;:&quot;xxxxxx&quot;}</code></pre><blockquote><p>重写父类的时候，一定要注意，如果父类有返回值限制的话，那么也必须跟父类一个类型不然就会报错。这的 format 在父类的时候限制返回的 string ，所以我们也需要在返回值限定那 string</p></blockquote><blockquote><p>参考地址：</p><p><a href="https://www.jianshu.com/p/b8e0ef4ef249" target="_blank" rel="noopener">https://www.jianshu.com/p/b8e0ef4ef249</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Composer</title>
      <link href="/2019/09/06/Composer/"/>
      <url>/2019/09/06/Composer/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>先了解一下历史，从拷贝第三方代码到项目中(1994)，到 PEAR 安装依赖包(1999)，再到 Composer 兴起(2012)，PHP 社区经历了将近 20 年的探索。PHP 这门古老的语言，也在不断的发展更新，在 Web 领域一直发光发热。 Composer 作为目前 PHP 包依赖管理的最佳工具，值得每一位 PHP 开发人员掌握。</p><h3 id="中文官网"><a href="#中文官网" class="headerlink" title="中文官网"></a>中文官网</h3><p><a href="https://www.phpcomposer.com/" target="_blank" rel="noopener">https://www.phpcomposer.com/</a></p><h3 id="什么是-Composer-？"><a href="#什么是-Composer-？" class="headerlink" title="什么是 Composer ？"></a>什么是 Composer ？</h3><p>是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会自动帮你安装这些依赖的库文件。</p><h3 id="扩展和包"><a href="#扩展和包" class="headerlink" title="扩展和包"></a>扩展和包</h3><p>拓展和包是两个非常相近的概念。在 PHP 世界里，一般可以这样理解和区分两者：拓展（extension）和模块（module）等价，是用 C 语言写的功能合集。</p><p>包（package）和库（library）等价，主要是用 PHP 实现的功能合集；拓展以动态链接库（.dll或.so）的形式加载，包则是通过 require/include 方式加载。绝大部分时候，两者混用不会造成理解上的困难。</p><p>常见的拓展：GD、ZIP 、Memcached 、MySQLi 、 Redis 等 </p><p>常见的包：PHPMailer 、PHPOffice 、HTMLPurifier 等</p><h3 id="PEAR-与-PECL"><a href="#PEAR-与-PECL" class="headerlink" title="PEAR 与 PECL"></a>PEAR 与 PECL</h3><p>在 Composer 流行之前，PEAR 和 PECL 是更为 PHP 开发者所知的两个工具（社区）。PEAR 是 PHP 拓展和应用仓库（PHP Extension and Application Repository）的缩写，官网<a href="http://pear.php.net/" target="_blank" rel="noopener">http://pear.php.net</a>；PECL 是 PHP 拓展社区库（PHP Extension Community Library）的缩写，官网<a href="http://pecl.php.net/" target="_blank" rel="noopener">http://pecl.php.net</a>。</p><p>两者的区别可用拓展和包来区分：PECL 托管拓展，源代码多为 C 文件，例如 APC、AMPQ 等；PEAR 托管包，功能用 PHP 实现，如 PHP CodeSniffer、HTTP Request 等；PEAR 对应 pear 命令， PECL 对应 pecl 命令，可用这两个命令安装和管理拓展和包（ pear 的 build/pickle 子命令也可以编译 PECL 中的拓展）。两者互为补充，官网以姐妹（sisters）形容两者的关系。</p><p>PECL 是官方拓展的补充，目前仍处于活跃状态，一些优秀的拓展有成为官方拓展的潜质。韩天峰大神的 swoole 拓展也托管在 PECL 中，国内名气非常高。相比之下 PEAR 已是明日黄花。PEAR2 和 Pyrus（下一代的PEAR 包安装工具，基于 PHP5.3+ 构建，官网<a href="http://pear2.php.net/" target="_blank" rel="noopener">http://pear2.php.net</a>）的出现也未能挽救 PEAR 。PEAR 没落伴随着本文主角 Composer 的兴起。</p><p>PEAR 的定位是“提供可复用的 PHP 组件”，以中心化的方式为开发者提供功能包。中心化发布的方式保证了代码的质量，同时带来维护上的不便：通过评审的包才能发布，包过时现象严重。PEAR 安装的包是全局的，不能为单独项目安装依赖包，非特权用户不能自行安装依赖包。其他缺点还包括糟糕的依赖管理。随着 Github 的流行和 Composer 的出现，包管理进入 Composer 时代。PEAR 已经完成其历史使命，可以安心的去了。</p><h3 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h3><p>严格来说，Composer 的定位是依赖管理工具而非包管理器。Composer 中文网对 Composer 工作介绍如下。Composer 将这样为你解决问题：</p><p>a) 你有一个项目依赖于若干个库。</p><p>b) 其中一些库依赖于其他库。</p><p>c) 你声明你所依赖的东西。</p><p>d) Composer 会找出哪个版本的包需要安装，并安装它们（将它们下载到你的项目中）。</p><p>PEAR 能做的事情，Composer 都能做（包括安装 PECL 拓展），部分还能做得更好。Composer 默认把包安装在项目目录下，普通用户就能正常使用（ Composer 官方建议不要以 root 身份执行 Composer 命令）；鼓励遵循最佳实践（即大名鼎鼎的 PSR 规范，详情见 PHP-FIG 官网<a href="https://www.php-fig.org/" target="_blank" rel="noopener">https://www.php-fig.org</a>），极大的推动 PHP 社区编码风格的规范化；Composer 是去中心化的平台，任何人均可发布代码包；发布包无需评审，包的质量由用户投票决定…作为 PEAR 的继任者，Composer 的表现经受住了社区的考验，并成为事实上的依赖管理标准工具。</p><p>Composer 目前已经形成庞大的生态，在数量上，Composer 的包远超 PEAR 。由于任何人均可自由发布包且无需评审，Composer 生态中的包可能存在代码质量参差不齐、代码风格各异、后门漏洞等隐忧。另外 Composer 的依赖管理以项目为单位，一台机器上可能多次安装同一个包。但瑕不掩瑜，总体而言，Composer 极大的改变了 PHP 的开发生态，促进了代码交流和社区发展。</p><h3 id="Composer-用法"><a href="#Composer-用法" class="headerlink" title="Composer 用法"></a>Composer 用法</h3><p>Composer 为管理的项目的依赖而生，项目中的 composer.json 文件是其工作的依据。该文件中最重要的部分是 require 部分，该部分告诉 Composer 期望安装的<strong>包及其版本</strong>，例如：</p><pre><code>{    &quot;name&quot;: &quot;tinywan/easy-live&quot;,    &quot;description&quot;: &quot;nginx live module&quot;,    &quot;type&quot;: &quot;library&quot;,    &quot;license&quot;: &quot;MIT&quot;,    &quot;authors&quot;: [        {            &quot;name&quot;: &quot;Tinywan&quot;,            &quot;email&quot;: &quot;756684177@qq.com&quot;        }    ],    &quot;require&quot;: {        &quot;php&quot;: &quot;&gt;=7.0&quot;    },    &quot;autoload&quot;: {        &quot;psr-4&quot;: {            &quot;live\\&quot;: &quot;src&quot;        }    }}</code></pre><p>用 Lravel 的 composer.json  演示：</p><p><img src="https://i.loli.net/2020/02/16/7aY8NL5EqGxQ3yh.png" alt="2020-02-16_13-43.png"></p><p> 然后运行 composer install 命令，Composer 会自动分析依赖，安装最合适的包到 vendor 目录下。加 -v (-vv, -vvv)选项会打印命令执行过程中的详细信息。安装完毕后，vendor 目录下会生成 autoload.php 文件。在项目的入口文件中包含此文件： <strong>require DIR . “/vendor/autoload.php”</strong>;，接下来便可在项目的任何地方引用依赖包中的接口和类。</p><p>除 install 命令，Composer 提供了许多其他命令管理依赖。常用的命令场景包括：查找依赖、引入依赖、安装依赖、更新依赖。分别对应的命令是：</p><table><thead><tr><th align="center">命令</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">composer search</td><td align="center">根据关键字查找依赖包</td></tr><tr><td align="center">composer request</td><td align="center">引入依赖，声明项目或者全局( global，用户名全局，非系统全局)依赖某个包</td></tr><tr><td align="center">composer install</td><td align="center">安装 composer.json 声明的依赖包，最终安装的依赖包版本可能取决于有无 composer.lock 文件</td></tr><tr><td align="center">composer update</td><td align="center">更新依赖到最新版本，相当于删除 composer.lock 文件后执行 composer install</td></tr><tr><td align="center">composer info</td><td align="center">查看安装的依赖包信息，与 composer show 等价</td></tr><tr><td align="center">composer dumpautoload</td><td align="center">加 -o 选项可导出优化的加载器</td></tr><tr><td align="center">composer why(-not)</td><td align="center">查看（不）安装某个包的原因</td></tr></tbody></table><h3 id="Composer-加速"><a href="#Composer-加速" class="headerlink" title="Composer 加速"></a>Composer 加速</h3><p>有的时候会因为各种原因，我们使用 Composer 的时候回感觉安装的特别慢，网络问题是一个方面，我们可以使用一些国内的镜像来解决网络的问题，但是依然有些慢，因为 Composer 是单进程方式下载的，也就是说 Composer 安装完一个依赖，才回去下载并安装另一个依赖，任何网络问题都会让这个进程卡主。那么有没有一种方法让 Composer 并发下载所有依赖呢，这样整体安装速度不就会快很多吗？</p><p><a href="https://github.com/hirak/prestissimo" target="_blank" rel="noopener">hirak/prestissimo</a> 就是利用这个思路来加速 Composer 的，看一下这个包的描述 ——composer parallel install plugin （Composer 并行安装插件）。</p><pre><code>composer global require hirak/prestissimo</code></pre><p>切换国内阿里云镜像</p><p><a href="https://developer.aliyun.com/composer" target="_blank" rel="noopener">https://developer.aliyun.com/composer</a></p><pre><code>composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</code></pre><h3 id="Composer-加载机制"><a href="#Composer-加载机制" class="headerlink" title="Composer 加载机制"></a>Composer 加载机制</h3><p>使用 Composer 最大的好处是只需最开始 require 一个 autoload.php 文件，就可以 new 你所需要的类了，不再需要传统的方式 A 文件内各种 include 跳到 B 文件又各种 include，非常头疼。</p><p>Composer 的核心就是二个函数：spl_autoload_register 与 require_once</p><p>spl_autoload_register — 注册给定的函数作为 __autoload 的实现</p><p><strong>说明</strong></p><pre><code>spl_autoload_register ([ callable $autoload_function [, bool $throw = true [, bool $prepend = false ]]] ) : bool</code></pre><p>将函数注册到 SPL __autoload 函数队列中。如果该队列中的函数尚未激活，则激活它们。</p><p>如果在你的程序中已经实现了<a href="https://www.php.net/manual/zh/function.autoload.php" target="_blank" rel="noopener">__autoload()</a> 函数，它必须显式注册到<a href="https://www.php.net/manual/zh/function.autoload.php" target="_blank" rel="noopener">__autoload()</a> 队列中。因为  <strong>spl_autoload_register()</strong> 函数会将 Zend Engine 中的<a href="https://www.php.net/manual/zh/function.autoload.php" target="_blank" rel="noopener">__autoload()</a> 函数取代为 <a href="https://www.php.net/manual/zh/function.spl-autoload.php" target="_blank" rel="noopener">spl_autoload()</a> 或<a href="https://www.php.net/manual/zh/function.spl-autoload-call.php" target="_blank" rel="noopener">spl_autoload_call()</a>。</p><p>如果需要多条 autoload 函数，<strong>spl_autoload_register()</strong> 满足了此类需求。 它实际上创建了 autoload 函数的队列，按定义时的顺序逐个执行。相比之下， <a href="https://www.php.net/manual/zh/function.autoload.php" target="_blank" rel="noopener">__autoload()</a> 只可以定义一次。</p><p>注意：__autoload() 函数在 PHP7.2 以后就不支持了。综合起来该用那个明白来吧。</p><p>一个简单的自动加载：</p><pre><code>// loadclass函数不具备自动加载类的功能function loadclass($classname){    $filename = &quot;./class/&quot;.$classname.&quot;.class.php&quot;;    if(is_file($filename)){        include $filename;    }}// spl_autoload_register()函数让这个 loadclass 具备了自动加载类的功能spl_autoload_register(&quot;loadclass&quot;);</code></pre><p>不使用 Composer 的代码执行会比使用 Composer 的代码执行更快，Composer 是自动加载，尽管是不用的库。这个效率毕竟大概是在几十ms的差距。我们可以优化自动加载，做一个项目 Composer 优化提速。</p><pre class="line-numbers language-php"><code class="language-php">composer dumpautoload <span class="token operator">-</span>o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令不止针对于 Laravel 程序，适用于所有使用 <code>composer</code> 来构建的程序。此命令会把 <code>PSR-0</code> 和 <code>PSR-4</code> 转换为一个类映射表，来提高类的加载速度。</p><p>当然作为 艺术家的框架，Laravel 也为我们提供了 Composer 的优化处理</p><pre class="line-numbers language-php"><code class="language-php"><span class="token shell-comment comment"># 官方解释：缓存框架引导文件</span>php artisan optimize<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>参考地址</p><p><a href="https://www.cnblogs.com/tinywan/p/8855236.html" target="_blank" rel="noopener">https://www.cnblogs.com/tinywan/p/8855236.html</a></p><p><a href="https://learnku.com/courses/laravel-package/2019/hirakprestissimo/1695" target="_blank" rel="noopener">https://learnku.com/courses/laravel-package/2019/hirakprestissimo/1695</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Composer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-存储引擎</title>
      <link href="/2019/08/21/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2019/08/21/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><blockquote><p>MySQL 当中最最常用的存储引擎- Myisam 和 Innodb，他们二兄弟是 MySQL 当中最最常用的二个存储引擎了。当然 MySQL 的存储引擎不止他们二兄弟还有别的一些存储引擎，本着<strong>既存在即合理的原则</strong>，我们不能单方面的去评价谁好谁不好，只能说他们在不同的场景当中发挥的功力不同。那什么是存储引擎呢？</p></blockquote><p>首先我们要晓得 MySQL 的数据属于持久化存储的，表里面的数据最终都是存储在磁盘当中的，具体如何存储的，这个无需我们关心，但是要清楚存储的方式有很多种；好比一部电影，在硬盘上可以有不同的存储格式（比如：MP4、wmv、avi、rmvb、flv），它们所占的空间与清晰程度都是不一样的。</p><p>存储引擎说白了就是如何存储数据、如何为存储的数据建立索引、如何更新查询数据、如何删除数据等等技术的实现方法。引擎不同，组织处理数据的方式就不同，在关系型数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型（即存储和操作此表的类型）注意：表有引擎，而库是没有引擎。</p><blockquote><p>在 Oracle 和 SQL Server 等数据库中只有一种存储引擎，所有数据存储管理机制都是一样的而 MySQL 数据库提供了多种存储引擎。用户可以根据不同的需求为数据表选择不同的存储引擎，用户也可以根据自己的需要编写自己的存储引擎。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g6ay8oo1rdj21fo0u0gsd.jpg" alt></p><h2 id="Myisam"><a href="#Myisam" class="headerlink" title="Myisam"></a>Myisam</h2><blockquote><p>5.5之前的版本默认的存储引擎就是 Myisam  ， Myisam 应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高。只考虑性能方面上来说 Innodb 完全比不上 Myisam 。</p><p>特点：不支持事务，不支持外键，并非处理稍差，支持压缩机制，支持表锁。</p></blockquote><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>Myisam 表是独立于操作系统的，这说明可以轻松地将其从 Windows 服务器移植到 Linux 服务器；每当我们建立一个 Myisam 引擎的表时，就会在本地磁盘上建立三个文件，详见</p><ul><li>*.FRM，存储表结构；</li><li>*.MYD，存储数据；</li><li>*.MYI，存储索引。</li></ul><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g69qbeiumtj20zw0lljw9.jpg" alt></p><p>① 静态 MyISAM ：<br>如果数据表中的各数据列的长度都是预先固定好的，即定长字段 char int float double ，服务器将自动选择这种表类型。因为数据表中每一条记录所占用的空间都是一样的，所以这种表存取和更新的效率非常高，并且容易缓存。当数据受损时，恢复工作也比较容易做</p><p>缺点是占用的空间通常比动态表多。静态表在数据存储时会根据列定义的宽度补足空格，但在访问的时候并不会得到这些空格，这些空格在返回给应用之前就已经去掉了。如果你需要返回字段后的空格，这种表类型就不可取</p><p>② 动态 MyISAM ：<br>如果数据表中出现 varchar、text 或 blob decimal  等变长字段时，服务器将自动选择这种表类型。相对于静态 MyISAM，这种表存储所占的空间比较小，但由于每条记录的长度不一，所以多次修改数据后，数据表中的数据就可能离散的存储在内存中，进而导致执行效率下降。同时，内存中也可能会出现很多碎片。因此，这种类型的表要经常用 optimize table 命令或优化工具来进行碎片整理，并且出现故障的时候恢复相对比较困难</p><p>③ 压缩 MyISAM ：<br>以上说到的两种类型的表都可以用 myisamchk 工具压缩。这种类型的表进一步减小了占用的存储空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支但是这种表压缩之后不能再被修改。另外，因为是压缩数据，所以这种表在读取的时候要先进行解压缩</p><h3 id="排列顺序"><a href="#排列顺序" class="headerlink" title="排列顺序"></a>排列顺序</h3><blockquote><p>Myisam  存储数据时不会按照主键 ID 值进行排序存储。该特点导致 Myisam 写入特别的快。</p></blockquote><h3 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h3><blockquote><p>Myisam 如果进行并发写入时，MySQL 会自动加锁保证数据的一致性，而 Myisam 加的是表锁。表锁会影响到整个数据表的操作。并发性稍微逊色。</p></blockquote><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>MyISAM 表无法处理事务，这就意味着有事务处理需求的表，不能使用 MyISAM 存储引擎。<br>MyISAM 存储引擎特别适合在以下几种情况使用：</p><ul><li>选择密集型的表：MyISAM 存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li><li>插入密集型的表：MyISAM 的并发插入特性允许同时选择和插入数据。例如：MyISAM 存储引擎很适合管理邮件或 Web 服务器日志数据。</li><li>对事务完整性没有要求或者以 SELECT、INSERT 为主的应用基本都可以使用这个引擎来创建表。</li></ul><h2 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h2><blockquote><p>在 MySQL 5.5 之后官方默认的存储引擎就是 Innodb， Innodb 提供事务和崩溃修复能力和支持外键。 Innodb 支持行锁还支持表锁。Innodb 不保持表的具体行数，他要扫描全表来计算行数，但是使用了 where 之后呢就跟 Myisam 一样。Innodb 文件格式不支持跨平台。表主键如果没有设定主键或者非空唯一索引，就会自动生成一个 6 字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。只要不是批量插入与查询其实与 Myisam 性能上差距不是很大。而且 Innodb 安全性上更优支持很多高级功能。</p><p>特点：支持事务，支持行锁，支持外键</p></blockquote><h3 id="存储方式-1"><a href="#存储方式-1" class="headerlink" title="存储方式"></a>存储方式</h3><p> Innodb 在 5.6 版本之前使用的共享存储，所有的表的数据和索引都存储在一个文件当中，文件名为 Inbdata1 。这样的共享存储的缺点就是所有表存储的索引和数据都存放在一个文件当中，表删除了，空间还没有及时释放掉，空间尺寸越大，带来的影响就是查询和添加速度变慢，因为都存在放一个文件中。另外如果此文件有所损坏，则 MySQL 中的所有的库数据都会不存在了。在 5.6 之后采用的独立空间存储，每个表的都是独立的存在。独立存储的好处每个 Innodb 引擎存储的索引与数据都存在每个独立的文件，因为每个表都是独立存储，插入语查询数据的压力小于共享存储，且如果不小心删除了存储文件那么顶多也就是一个表会受到影响。注意：<strong>在备份数据的时候不能直接复制可能会出现很多问题，备份数据的时候应当 mysqldump 注意如果数据量很大的话导出真的太费劲了</strong></p><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g6b16cawn8j21fo0u0qf3.jpg" alt></p><h3 id="排序顺序"><a href="#排序顺序" class="headerlink" title="排序顺序"></a>排序顺序</h3><blockquote><p> Innodb <strong>数据的写入顺序与数据存储顺序不一致</strong>，Innodb 会把数据按<strong>主键顺序排列</strong>，速度会比Myisam 慢一些。 Myisam 是数据怎么写入那么数据就怎么存储排列。</p></blockquote><h3 id="并发处理-1"><a href="#并发处理-1" class="headerlink" title="并发处理"></a>并发处理</h3><blockquote><p> Innodb 擅长处理并发，<strong>行级锁定</strong>，实现了行级锁定，在一定情况下可以选择行级锁定来提升并发性，也<strong>支持表级锁定</strong>，根据操作选择，<strong>只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</strong></p></blockquote><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>更新密集的表：InnoDB 存储引擎特别适合处理多重并发的更新请求</p><p>事务：InnoDB 存储引擎是支持事务的标准 MySQL 存储引擎</p><p>自动灾难恢复：与其它存储引擎不同，InnoDB 表能够自动从灾难中恢复</p><p>外键约束：MySQL 支持外键的存储引擎只有 InnoDB</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><blockquote><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。锁保证数据并发访问的一致性、有效性；锁冲突也是影响数据库并发访问性能的一个重要因素。锁是 MySQL 在服务器层和存储引擎层的的并发控制。</p><p>加锁是消耗资源的，锁的各种操作，包括获得锁、检测锁是否已解除、释放锁等。</p></blockquote><p>锁只支持一种特性，而事务支持四中。</p><p>一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p><pre><code>原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</code></pre><h3 id="共享锁与排他锁"><a href="#共享锁与排他锁" class="headerlink" title="共享锁与排他锁"></a>共享锁与排他锁</h3><p>共享锁(读锁)：其他事务可以读，但是不能写。</p><p>排他锁(写锁)：其他事务不可以读，也不可以写。</p><h3 id="颗粒锁"><a href="#颗粒锁" class="headerlink" title="颗粒锁"></a>颗粒锁</h3><p>Mysql 不同的存储引擎支持不同的锁机制，所有的存储引擎都以自己的方式显示了锁机制，服务器层完全不了解存储引擎中的锁实现：</p><ul><li>MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）</li><li>BDB 存储引擎采用的是页面锁（page-level locking），但也支持表级锁</li><li>InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。</li></ul><table><thead><tr><th align="center">锁</th><th align="center">加锁效率</th><th align="center">是否会死锁</th><th align="center">颗粒</th><th align="center">冲突</th><th align="center">并发</th></tr></thead><tbody><tr><td align="center">表级锁</td><td align="center">开销小，加锁快</td><td align="center">不会出现死锁</td><td align="center">锁定粒度大</td><td align="center">发生锁冲突的概率最高</td><td align="center">并发度最低</td></tr><tr><td align="center">行级锁</td><td align="center">开销大，加锁慢</td><td align="center">会出现死锁</td><td align="center">锁定颗粒最小</td><td align="center">发送锁冲突的概率最低</td><td align="center">并发度最高</td></tr><tr><td align="center">页面锁</td><td align="center">开销和加锁时间界于表锁和行锁之间</td><td align="center">会出现死锁</td><td align="center">锁定粒度界于表锁和行锁之间</td><td align="center">发送锁冲突的概率一般</td><td align="center">并发度一般</td></tr></tbody></table><p>默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。</p><p>但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p><h3 id="不同颗粒锁的比较"><a href="#不同颗粒锁的比较" class="headerlink" title="不同颗粒锁的比较"></a>不同颗粒锁的比较</h3><ul><li>表锁<ul><li>这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁</li><li>表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如 Web 应用</li></ul></li><li>行锁<ul><li>最大程度的支持并发，同时也带来了最大的锁开销。</li><li>在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。</li><li>行级锁只在存储引擎层实现，而 MySQL 服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统</li></ul></li></ul><h3 id="Myisam-表级锁模式"><a href="#Myisam-表级锁模式" class="headerlink" title="Myisam 表级锁模式"></a>Myisam 表级锁模式</h3><ul><li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li><li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</li></ul><p>Myisam 表的读操作与写操作之间，以及写操作之间是串联的。<strong>当一个线程获得对一个表写锁后，只有持有锁的线程可以进行表的更新操作。其他线程的读、写都会等待，直到锁被释放为止。</strong></p><p>默认情况下，写锁比读锁具有更高的优先级。当一个锁释放的时候，这个锁会优先给写锁队列中等候的获取锁请求，然后才会给读锁队列中等候的获取锁请求。这也正是 Myisam 表不太适合有大量更新操作的和查询操作应用的原因。因为大量的更新操作会导致查询操作很难获得读锁，从而可能导致永远阻塞。同时一些需要长时间运行的查询操作，也会使写线程“饿死”应用当中应当避免长时间的查询操作（在可能的情况下可以通过使用中间表等措施对SQL 语句做一定的“分解” ，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行）。</p><p>可以设置改变读锁和写锁的优先级：</p><ul><li>通过指定启动参数 low-priority-updates，使 MyISAM 引擎默认给予读请求以优先的权利。</li><li>通过执行命令 SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。</li><li>通过指定 INSERT、UPDATE 、DELETE 语句的 LOW_PRIORITY 属性，降低该语句的优先级。<br>给系统参数 max_write_lock_count 设置一个合适的值，当一个表的读锁达到这个值后，MySQL 就暂时将写请求的优先级降低，给读进程一定获得锁的机会。</li></ul><h3 id="Myisam加表锁方法"><a href="#Myisam加表锁方法" class="headerlink" title="Myisam加表锁方法"></a>Myisam加表锁方法</h3><p>Myisam 在执行查询语句 select 前，会自动给涉及的表加读锁。</p><p>Myisam 在执行更新操作 update dalete insert 前，会自动给涉及的表加写锁。</p><blockquote><p>这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 Myisam 表显式加锁。</p><p>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。</p></blockquote><p>MyISAM 存储引擎支持并发插入，以减少给定表的读和写操作之间的争用：</p><p>如果 MyISAM 表在数据文件中间没有空闲块，则行始终插入数据文件的末尾。 在这种情况下，你可以自由混合并发使用 MyISAM 表的 INSERT 和 SELECT 语句而不需要加锁——你可以在其他线程进行读操作的时候，同时将行插入到 MyISAM 表中。 文件中间的空闲块可能是从表格中间删除或更新的行而产生的。 如果文件中间有空闲快，则并发插入会被禁用，但是当所有空闲块都填充有新数据时，它又会自动重新启用。 要控制此行为，可以使用 MySQL 的 concurrent_insert 系统变量。</p><p>如果你使用 LOCK TABLES 显式获取表锁，则可以请求 READ LOCAL 锁而不是 READ 锁，以便在锁定表时，其他会话可以使用并发插入。</p><ul><li>当 concurrent_insert 设置为0时，不允许并发插入。</li><li>当 concurrent_insert 设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM 允许在一个线程读表的同时，另一个线程从表尾插入记录。这也是 MySQL 的默认设置。</li><li>当 concurrent_insert 设置为2时，无论 MyISAM 表中有没有空洞，都允许在表尾并发插入记录。</li></ul><h3 id="查询表级锁争用情况"><a href="#查询表级锁争用情况" class="headerlink" title="查询表级锁争用情况"></a>查询表级锁争用情况</h3><p>可以通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁的争夺，如果 Table_locks_waited 的值比较高，则说明存在着较严重的表级锁争用情况：</p><pre class="line-numbers language-mysql"><code class="language-mysql">mysql> SHOW STATUS LIKE 'Table%';+-----------------------+---------+| Variable_name | Value |+-----------------------+---------+| Table_locks_immediate | 1151552 || Table_locks_waited | 15324 |+-----------------------+---------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Innodb行级锁和表级锁"><a href="#Innodb行级锁和表级锁" class="headerlink" title="Innodb行级锁和表级锁"></a>Innodb行级锁和表级锁</h3><p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li></ul><blockquote><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p></blockquote><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li></ul><p><strong>锁模式的兼容情况</strong></p><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g6dfpsdoulj20k006qwep.jpg" alt></p><blockquote><p>如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。</p></blockquote><h3 id="Innodb加锁方法"><a href="#Innodb加锁方法" class="headerlink" title="Innodb加锁方法"></a>Innodb加锁方法</h3><ul><li><p>意向锁是 Innodb自 动加的，不需要用户干预。</p></li><li><p>对于对于 update insert delete 语句， innodb 会自动给涉及数据集加排他锁（X)；</p></li><li><p>对于普通 select 语句 innodb 不会加任何锁。</p></li><li><p>事务可以通过以下语句显式给记录集加共享锁或排他锁：</p><ul><li>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li><li>排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</li></ul></li></ul><h3 id="InnoDB-行锁实现方式"><a href="#InnoDB-行锁实现方式" class="headerlink" title="InnoDB 行锁实现方式"></a>InnoDB 行锁实现方式</h3><ul><li>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</li><li>不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。</li><li>只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时，<br>别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。（更多阅读：<a href="https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s/h4B84UmzAUJ81iBY_FXNOg" target="_blank" rel="noopener">MySQL索引总结</a>）</li><li>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个 session 是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的（后使用这些索引的 session 需要等待先使用索引的session 释放锁后，才能获取锁）。 应用设计的时候要注意这一点。</li></ul><h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><ul><li><p><strong>乐观锁(Optimistic Lock)</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。</p><ul><li>乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于 write_condition 机制的其实都是提供的乐观锁。</li></ul></li><li><p><strong>悲观锁(Pessimistic Lock)</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p><ul><li>悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li></ul></li></ul><h3 id="一些优化锁性能的建议"><a href="#一些优化锁性能的建议" class="headerlink" title="一些优化锁性能的建议"></a>一些优化锁性能的建议</h3><ul><li>尽量使用较低的隔离级别；</li><li>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会</li><li>选择合理的事务大小，小事务发生锁冲突的几率也更小</li><li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁</li><li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会</li><li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响</li><li>不要申请超过实际需要的锁级别</li><li>除非必须，查询时不要显示加锁。 MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能； MVCC 只在 COMMITTED READ（读提交）和 REPEATABLE READ（可重复读）两种隔离级别下工作</li><li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote><p>索引是存储引擎用于快速找到记录的一种数据结构。如果说没有索引的话，数据库就必须重第一条记录开始进行全表扫描，直到找出相关的行。数据越多，检索的代价就越高，检索时如果表的列存在索引，那么 MySQL 就能快速到达指定位置去搜索数据文件，而不必查看所有数据。注意有些情况下，MySQL 如果觉得全表扫描来的好，那么也不会去走索引。</p><p><strong>索引是一种以空间换取时间的方式，牺牲了写的速度，提高查询速度，创建完毕索引后，写慢读快</strong></p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>索引依托于存储引擎的实现，因此，每种存储引擎的索引都不一定完全的相同，并且每种存储引擎也不一定支持所有的索引类型。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。大多数存储引擎有更高的额限制。</p></blockquote><p>MySQL 中索引的存储类型有两种： BTREE 和 HASH ，具体和表的存储引擎相关；</p><p>为什么我们添加完索引后查询速度为变快？</p><p>传统的查询方法，是按照表的顺序遍历的，不论查询几条数据，MySQL 需要将表的数据从头到尾遍历一遍，在我们添加完索引之后， MySQL 一般通过 BTREE 算法生成一个索引文件，在查询数据库时，找到索引文件进行遍历(折半查找大幅查询效率)，找到相应的键从而获取数据。</p><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>在 MySQL 索引默认有 btree 和 hash 两种类型，Myisam ,Innodb 中,默认用 btree 索引类型。</p><p>两者的区别：</p><ul><li>hash 函数计算后的结果,是随机的,如果是在磁盘上放置数据,添加的数据行在磁盘上随机放置,点对点的查询速度最快。  select name from id=1;</li><li>hash 类型不能对范围查询进行优化</li><li>无法利用前缀索引，比如 在 btree 中, 字段值 “zhangsan” ,查询 字段=“zhang”,可以利用索引,而 hash 类型则不行</li><li>排序也无法优化</li><li>通过索引拿到数据位置,必须回到表中取数据</li></ul><p>优点：</p><ul><li>加快数据的查询速度</li><li>唯一索引，可以保证数据库表中每一行数据的唯一性</li><li>在实现数据的参考完整性方面，可以加速表和表之间的连接</li><li>在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间</li></ul><p>缺点：</p><ul><li>占用磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸（<strong>合理运用，问题不大</strong>）</li><li>损耗性能（<strong>添加、修改、删除</strong>） 索引需要动态地维护</li></ul><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p><strong>普通索引，组合索引</strong>：<strong>对关键字没有要求</strong>。</p><pre class="line-numbers language-mysql"><code class="language-mysql">alter table 表名 add index 索引名称 (`创建索引的字段`); # 普通索引alter table 表名 add index 索引名称 (`创建索引的字段`,`创建索引的字段`); # 组合索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>唯一索引</strong>：<strong>要求关键字不能重复，同时增加唯一约束</strong>。</p><pre class="line-numbers language-mysql"><code class="language-mysql">alter table 表名 add unique index 索引名称 (`创建索引的字段`);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>主键索引</strong>：<strong>要求关键字不能重复，也不能为 NULL 。同时增加主键约束</strong>。</p><pre class="line-numbers language-mysql"><code class="language-mysql">alter table 表名 add primary key 索引名称 (`创建索引的字段`);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>全文索引</strong>：<strong>关键字的来源不是所有字段的数据，而是从字段中提取的特别关键词</strong>。</p><pre class="line-numbers language-mysql"><code class="language-mysql">alter table 表名 add fulltext (`创建索引的内容`);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看索引</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">show index from 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>删除索引</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">alter table 表名 drop index 索引名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><blockquote><p>索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍，高效的索引对于获得良好的性能非常重要。</p></blockquote><ol><li><p>索引并非越多越好，一个表当中如果有大量的索引，那么他还会影响到更新操作（insert、update、delete）的性能，因为当表的数据更改的同时，索引也会进行调整和更新。</p></li><li><p>避免对<strong>经常更新的表</strong>设计过多的索引，并且索引中的列尽可能要少，而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段</p></li><li><p>数据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引时间还要短，索引可能不会产生优化效果</p></li><li><p>在条件表达式中经常用到的不同值较多的列上建立索引，在不同值较少的列上不要建立索引，比如性别字段只有男和女，就没必要建立索引。如果建立索引不但不会提高查询效率，反而会严重降低更新速度</p></li><li><p>当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度</p></li><li><p>在频繁排序或分组（即 group by 或 order by 操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引 </p></li></ol><p>总结：<br>    较频繁的作为查询条件字段应该创建索引<br>    唯一性太差的字段不适合创建索引，尽管频繁作为查询条件，例如 gender 性别字段<br>    更新非常频繁的字段不适合作为索引<br>    不会出现在 where 子句中的字段不该创建索引</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>1、 存储结构</strong></p><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。<br>InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><p><strong>2、 存储空间</strong></p><p>MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。<br>InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p><p><strong>3、 可移植性、备份及恢复</strong></p><p>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。<br>InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p><p><strong>4、 事务支持</strong></p><p>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。<br>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p><p><strong>5、 AUTO_INCREMENT</strong></p><p>MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。<br>InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p><p><strong>6、 表锁差异</strong></p><p>MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。<br>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p><p><strong>7、 表主键</strong></p><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。<br>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</p><p><strong>8、 表的具体行数</strong></p><p>MyISAM：保存有表的总行数，如果select count(<em>) from table;会直接取出出该值。<br>InnoDB：没有保存表的总行数，如果使用select count(</em>) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p><p><strong>9、 CURD操作</strong></p><p>MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。<br>InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p><p><strong>10、 外键</strong></p><p>MyISAM：不支持<br>InnoDB：支持<br>通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。</p><p>表锁，行锁，行锁副作用（update 多时候变慢），在 select 和 update 混合的情况下，行锁巧妙解决了读写互斥的问题；</p><p>而 Innodb 由于支持行锁，所以在数据修改方面更胜一筹</p><blockquote><p>参考地址：</p><p><a href="https://zhuanlan.zhihu.com/p/29150809" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29150809</a></p><p><a href="https://blog.csdn.net/qq_19865749/article/details/79309387" target="_blank" rel="noopener">https://blog.csdn.net/qq_19865749/article/details/79309387</a></p><p><a href="https://juejin.im/entry/5a448726f265da43062b10f1" target="_blank" rel="noopener">https://juejin.im/entry/5a448726f265da43062b10f1</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP+Nginx执行请求的原理</title>
      <link href="/2019/08/18/PHP-Nginx%E6%89%A7%E8%A1%8C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/18/PHP-Nginx%E6%89%A7%E8%A1%8C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><blockquote><p>当我们访问一个 Web 站点，PHP 和 Nginx 是怎么去执行的呢？</p><p>浏览器发起请求 -&gt;  web_server(nginx)  分发处理-&gt;  PHP 执行代码返回结果</p></blockquote><h3 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h3><ul><li><p>CGI<br>CGI 是 Web 服务器运行外部程序的规范。意思就是通过 CGI 可以与你的程序通信，通过 CGI 标准格式。你的程序可以和浏览器交互。</p><blockquote><p>简单理解 CGI 就是一个协议，规定了一些东西该怎么传，你的程序这边怎么接受处理等规范。</p></blockquote></li><li><p>PHP-CGI<br>PHP-CGI 就是 CGI 协议 PHP 的一个实现版。PHP-CGI 会为每个请求 fork 一个进程处理，处理完成后退出。(这个模式叫做 fork-and-execute)。这样的模式不符合现在动不动大规模的流量，所以已退出历史舞台。</p></li><li><p>FastCGI<br>FastCGI 是 CGI 的升级版，他会预先启动一个 master 进程读取配置文件，然后 fork 多个 work 进程等待连接。监听到请求，分配给 work 进程做具体的处理。这样大大提高了程序的性能。</p><blockquote><p>FastCGi 会管理进程，处理完成后不会轻易销毁。而 CGI 会为每一个请求，创建进程，销毁进程。</p></blockquote></li><li><p>PHPFPM<br>作为世界上最好的语言，当然要跟上潮流。当发现 PHP-CGI 性能不佳时，又恰好出现了 FastCGI 协议。所以 PHP 实现了一个 PHP 版本的 FastCGI，名字叫做 PHPFPM（FastCGI Process Manager）。 PHPFPM 启动时会开启 一个 master 进程和若干个 work 进程。master 进程监听请求，并转发给 work 进程处理，每一个 work 进程都有一个 PHP 解释器，你的代码在每一个 work 进程中都有一份，work 进程是真正执行代码的地方。</p></li></ul><h3 id="一次完整的流程"><a href="#一次完整的流程" class="headerlink" title="一次完整的流程"></a>一次完整的流程</h3><p>首先用户访问 Web 站点</p><p>域名进行 DNS 解析</p><p>DNS 解析完成之后，发起 TCP 协议的三次捂手</p><p>HTTP 请求对应 IP 服务器和端口</p><p>Nginx 监听到对应的端口请求之后</p><p>Nginx 会对 URL 做一个 Location 的正则匹配</p><p>如果是静态资源则返回文件，Nginx 响应 HTTP 请求</p><p>如果是动态资源，通过正则匹配到请求 PHP 脚本，那么他会通过 Nginx 的模块 ngx_http_fastcgi_module 把请求分发给 PHPFPM 处理，也就是 Nginx 配置文件当中的 fastcgi_pass=127.0.0.1:9000 这种属于网络模式</p><p>PHPFPM master 进程监听到请求之后，分配给 work 处理（每一个 work 进程中都有一个 PHP 解释器），PHPFPM 在启动的时候已经 work 进程已经加载了配置，加载了你写的代码。所以说 work 进程接收到请求后立马执行，然后 work 进程执行返回的结果给 Nginx，Nginx 响应 HTTP 请求。</p><h3 id="ngx-http-fastcgi-module-模块"><a href="#ngx-http-fastcgi-module-模块" class="headerlink" title="ngx_http_fastcgi_module 模块"></a>ngx_http_fastcgi_module 模块</h3><p>在浏览器请求 web_server 是 HTTP 协议 或者 HTTPS 协议，但是 PHPFPM 不懂怎么办了？这里 Nginx 提供了一个 ngx_http_fastcgi_module ，ngx_http_fastcgi_module 把 HTTP 或者 HTTPS 请求 映射成 FastCGI 请求。这样 PHP 程序就能和用户互动了。</p><h3 id="PHP-平滑重启原理"><a href="#PHP-平滑重启原理" class="headerlink" title="PHP 平滑重启原理"></a>PHP 平滑重启原理</h3><p>每次修改完 PHP.ini 配置并重启后，会启动新的 worker 进程加载新的配置，而之前已经存在的进程会在工作完成之后销毁，因此实现平滑重启</p><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。</p><p>线程：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。一个程序至少一个进程，一个进程至少一个线程。</p><p><strong>进程线程的区别：</strong></p><ul><li>地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。</li><li>资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。</li></ul><p>　　　　　一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p><p>　　　　　进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程</p><ul><li>执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>线程是处理器调度的基本单位，但是进程不是。</li><li>两者均可并发执行。</li></ul><p><strong>优缺点：</strong></p><p>　　线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。</p><p>　　进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。</p><p>  <strong>何时使用多进程，何时使用多线程？</strong></p><p>对资源的管理和保护要求高，不限制开销和效率时，使用多进程。</p><p>要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。</p><blockquote><p>参考地址：</p><p><a href="https://learnku.com/articles/32318#reply104413" target="_blank" rel="noopener">https://learnku.com/articles/32318#reply104413</a></p><p><a href="https://www.cnblogs.com/zhuzhu2016/p/5804875.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuzhu2016/p/5804875.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2019/08/17/Dokcer/"/>
      <url>/2019/08/17/Dokcer/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>2010 年，几个搞 IT 的年轻人，在美国旧金山成立了一家名叫 “dotCloud” 的公司。</p><p>这家公司主要提供基于 PaaS 的云计算技术服务。具体来说，是和 LXC 有关的容器技术。</p><p>LXC 也就是 Linux 容器虚拟化技术。</p><p>后来，dotCloud 公司将自己的容器技术进行了简化和标准化，并命名为——<strong>Docker</strong>。</p><p>Docker 技术诞生之后，并没有引起行业的关注。而 dotCloud 公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。</p><p>正当他们快要坚持不下去的时候，脑子里蹦出了 “开源” 的想法。</p><p>什么是 “开源” ？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。</p><p>有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。</p><p>2013 年 3 月，dotCloud 公司的创始人之一，Docker 之父，28 岁的 *<em>Solomon Hykes *</em>正式决定，将 Docker 项目开源。</p><p>不开则已，一开惊人。</p><p>越来越多的 IT 工程师发现了 Docker 的优点，然后蜂拥而至，加入 Docker 开源社区。</p><p>Docker 的人气迅速攀升，速度之快，令人瞠目结舌。</p><p>开源当月，Docker 0.1 版本发布。此后的每一个月，Docker 都会发布一个版本。到 2014 年 6 月 9 日，Docker 1.0 版本正式发布。</p><p>此时的 Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像 Google、微软、Amazon、VMware 这样的巨头，都对它青睐有加，表示将全力支持。</p><p>Docker 火了之后，dotCloud 公司干脆把公司名字也改成了 Docker Inc. 。</p><p>Docker 和容器技术为什么会这么火爆？说白了，就是因为它“轻”。</p><p>在容器技术之前，业界的网红是<strong>虚拟机</strong>。虚拟机技术的代表，是 VMWare 和 OpenStack。</p><p>相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。</p><p>在“子电脑”里，你可以和正常电脑一样运行程序，例如开 QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上 QQ。“子电脑”和“子电脑”之间，是<strong>相互隔离</strong>的，互不影响。</p><p>虚拟机属于虚拟化技术。而 Docker 这样的容器技术，也是虚拟化技术，属于<strong>轻量级的虚拟化</strong>。</p><p>虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如 VMWare ）。</p><p>而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。</p><p>它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个 Docker 容器）。此外，它占的空间很小，虚拟机一般要几 GB 到几十 GB 的空间，而容器只需要 MB 级甚至 KB 级。</p><p><img src="https://i.loli.net/2020/01/15/cz6OW7Kum9NXCZH.png" alt="2020-01-15_12-03.png"></p><p>正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。</p><p>Docker 技术的三大核心概念，分别是：</p><ul><li><strong>镜像（Image）</strong></li><li><strong>容器（Container）</strong></li><li><strong>仓库（Repository）</strong></li></ul><p>其实在简单点来说 Docker 的好处，“在我的机器上可正常工作”的问题。 运维人员利用 Docker 可以在隔离容器中并行运行和管理应用，获得更好的计算密度。 企业利用 Docker 可以构建敏捷的软件交付管道，以更快的速度、更高的安全性和可靠的信誉为 Linux 和 Windows Server 应用发布新功能。</p><p>总结为一句话：简单，快捷，方便，一次构建，到处运行。解决了我们环境的问题（本地开发好好的，上线又乱七八糟的了）</p><p><strong>转折点</strong>：</p><p>就在 Docker 容器技术被炒得热火朝天之时，大家发现，如果想要将 Docker 应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对 Docker 及容器进行更高级更灵活的管理。K8s，诞生了！</p><h3 id="熟悉几个命令"><a href="#熟悉几个命令" class="headerlink" title="熟悉几个命令"></a>熟悉几个命令</h3><table><thead><tr><th align="center">命令</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">systemctl start docker</td><td align="center">启动 docker</td></tr><tr><td align="center">docker images</td><td align="center">查看所有镜像</td></tr><tr><td align="center">docker pull &lt;库上的镜像&gt;</td><td align="center">在 dockerhub 当中拉取镜像</td></tr><tr><td align="center">docker rmi &lt;id/名称&gt;</td><td align="center">删除镜像</td></tr><tr><td align="center">docker run -p 80 –name nginx -d nginx</td><td align="center">创建容器：p端口号 d后台运行</td></tr><tr><td align="center">docker exec -it &lt;容器名称&gt; dash</td><td align="center">进入容器</td></tr><tr><td align="center">docker ps</td><td align="center">查看所有运行容器</td></tr><tr><td align="center">docker ps -a</td><td align="center">查看所有容器</td></tr><tr><td align="center">docker rm &lt;id/名称&gt;</td><td align="center">删除容器：要先关闭容器才能删</td></tr><tr><td align="center">docker stop &lt;容器&gt;</td><td align="center">停止容器</td></tr><tr><td align="center">docker start &lt;容器&gt;</td><td align="center">启动容器</td></tr><tr><td align="center">docker restart &lt;容器&gt;</td><td align="center">重启容器</td></tr><tr><td align="center">docker cp &lt;容器名称&gt;:/&lt;容器里文件&gt;</td><td align="center">docker 复制容器文件</td></tr><tr><td align="center">docker -v &lt;本地文件&gt;:/&lt;容器里文件&gt;</td><td align="center">docker 映射文件</td></tr></tbody></table><h3 id="MySQL-安装"><a href="#MySQL-安装" class="headerlink" title="MySQL 安装"></a>MySQL 安装</h3><p>从 Dockerhub 拉取 MySQL 镜像</p><pre><code>docker pull mysql</code></pre><p>实例容器,启动数据库：</p><pre><code>docker run -p 3306:3306 --name mysql -v /xxx:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d --privileged=true mysql### 命令说明：run 创建一个容器 --name 给容器的名称 （如果留空，docker会自动分配一个名称）-v 映射文件，预留，也可以不要-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口-e MYSQL_ROOT_PASSWORD=root：初始化 root 用户的密码-d 后台运行容器--privileged=true  可能会碰到权限问题，需要加参数# 进入容器docker exec -it mysql dash # 修改密码认证 mysql 8 加密方式改变了mysql&gt;ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;;mysql&gt;flush privileges;# 创建一个帐号，并且赋予权限mysql&gt;create user &#39;用户名&#39;@&#39;访问主机&#39; identified by &#39;密码&#39;;mysql&gt;grant 权限 on *.* to &#39;帐号&#39;@&#39;%&#39; WITH GRANT OPTION;# 中科大源,然后下载需要的软件sed -i &#39;s/deb.debian.org/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.listapt update# 修改 /etc/mysql/conf.d 下面的 myqsl.cnf 添加以下配置 注意配置当中的 mysql 要改为 mysqlddefault_authentication_plugin=mysql_native_password</code></pre><h3 id="PHP-FPM-安装"><a href="#PHP-FPM-安装" class="headerlink" title="PHP-FPM 安装"></a>PHP-FPM 安装</h3><pre><code>docker pull php:fpm</code></pre><p>实例容器,启动 PHP：</p><pre><code># 创建容器并且关联 MySQLdocker run --name php-fpm -p 9000:9000 --link mysql:mysql -v /宿主机存放代码的目录:/var/www/html -it -d php:fpm### 命令说明：run 创建一个新的容器--name 指定容器的名称-p 9000:9000：将容器的 9000 端口映射到主机的 9000 端口php-fpm 是 Dockerhub 上下载镜像名称（如果本地没有可用的镜像，Docker会自动下载一个）-it 表示让容器的标准输入打开,并且分配一个伪终端-d 后台启动。# 中科大源,然后下载需要的软件sed -i &#39;s/deb.debian.org/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.listapt update# Composer 安装1、curl -sS https://getcomposer.org/installer | php2、mv composer.phar /usr/local/bin/composer3、composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/# 修改 php-fpm.conf include 路径include=/usr/local/etc/php-fpm.d/*.conf# 开启扩展/usr/local/bin/docker-php-ext-install pdo_mysql# 已经在包存在的扩展直接可以这样安装了，没有的就得自己下载安装了。下载扩展到 /usr/src/php/ext 目录当中,注意：如果没有 /usr/src/php/ext 别慌执行一下 /usr/local/bin/docker-php-ext-install 一个没有的扩展，然后文件夹就会有了，每次安装好扩展之后 php 自动删除！# docker-php-ext-enable 可以控制扩展# 配置 nginx FastCGI 的请求location ~ \.php$ {  root           /var/www/html/;  fastcgi_pass   php-fpm:9000;  fastcgi_index  index.php;  include        fastcgi_params;  fastcgi_param SCRIPT_FILENAME /var/www/html/$fastcgi_script_name;}</code></pre><h3 id="Nginx-安装"><a href="#Nginx-安装" class="headerlink" title="Nginx 安装"></a>Nginx 安装</h3><p>从 Dockerhub 拉取 Nginx 镜像 </p><pre><code>docker pull nginx</code></pre><p>实例容器,启动 Nginx：</p><pre><code>docker run --name nginx_80 -p 80:80 --link php-fpm -v /宿主机存放代码的目录:/usr/share/nginx/html -d nginx### 命令说明run 创建一个新的容器--name 指定容器的名称-p 80:80：将容器的 80 端口映射到主机的 80 端口nginx 是 Dockerhub 上下载nginx镜像名称（如果本地没有可用的镜像，Docker会自动下载一个）-d 后台启动。# 中科大源,然后下载需要的软件sed -i &#39;s/deb.debian.org/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.listapt update</code></pre><h3 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h3><pre><code>docker pull memcached#实例容器,启动memcached：docker run --name memcached -p 11211:11211 -m 64m -d memcached# 中科大源,然后下载需要的软件sed -i &#39;s/deb.debian.org/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.listapt update#安装 memcached 的时候会去少依赖，根据下面评论安装即可搞定</code></pre><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><pre><code>docker pull redis#实例容器,启动redisdocker run --name redis -p 6379:6379  -d redis redis-server --appendonly yes# 中科大源,然后下载需要的软件sed -i &#39;s/deb.debian.org/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.listapt update# redis5以后 没有配置文件，需要自己去 redis 官方下载一个想对应的版本把里面的配置文件复制出来</code></pre><p><img src="https://i.loli.net/2019/09/26/16iHMtqA8BYZEeQ.png" alt></p><p><img src="https://i.loli.net/2019/09/26/JLyaowZkuSvNzmX.png" alt></p><blockquote><p>参考地址：</p><p><a href="https://zhuanlan.zhihu.com/p/53260098" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53260098</a></p></blockquote><h3 id="踩坑的路"><a href="#踩坑的路" class="headerlink" title="踩坑的路"></a>踩坑的路</h3><p>细心成就王者，这句话不是没有道理的呀！</p><h4 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h4><p>在之前也一直没有去执行过 Laravel 的 migrate 命令。今天在想要写一个朋友给的项目的时候，需要创建表，夸夸一顿操作。结果就是：<code>could not find driver</code></p><p>找不到驱动，下意识的就去看 <code>config/database.php</code>配置文件去了，认真的检查了一遍没有问题啊！然后又去<code>.env</code>看连接的信息是否哪里有问题，没问题啊！！！心里又在想是不是扩展没打开，马上 exec 到 Dokcer 的容器当中 PHP -m 查看 PDO 相关的扩展是不是没有。（其实问题已经出现了）</p><p>检查了一遍 Dokcer 容器里面的扩展发现还是没有问题，回过头来又去执行 migrate 还是不行。谷歌、百度了很久也没有找到解决的办法。实在没有办法了，就去救助我一个大哥了，搞了一些东西问题也没有解决。</p><p>’你去 Docker 里面运行一下  php artisan migrate ‘，恍然大悟！！！赶快 exec 到容器当中，执行了一下命令。。。成功了我靠搞半天原来是这样！！！因为宿主机没有这个环境，使用的都是 Docker 里面的环境，还在搞半天搞出一朵花来也运行不了！当然你要是同步 Docker 的环境就完全没有问题了。</p><h4 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h4><p>今天又跳坑里面了，自己想答一个 MySQL 的读写分离，创建了一个容器，绑定了端口 3307 结果第三方软件一直连接不上。</p><p>宿主机绑定了 3307 端口，但是 MySQL 忘记修改端口了，MySQL 默认使用的 3306。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会话技术</title>
      <link href="/2019/08/12/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/"/>
      <url>/2019/08/12/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>WEB 应用程序是使用 HTTP 协议传输数据，早期处于刚开始发展阶段时，属于文档浏览阶段（ HTTP/0.9 的时候只有文本传输，1.0 开始才支持图片、视频、二进制文件传输），不需要做交互，服务端不需要去记录先前的事务，这样服务端答复也很快（这就是 HTTP 无状态特性）。但随着 WEB 的发展，进入交互时代，这时候我们就需要跟服务端做交互了，比如我们要保持用户的登录状态而我们 HTTP 协议却办不到，因为  HTTP 协议属于无状态他对先前事务处理没有记忆的功能，一次请求完成就立马断开。通俗的来讲就是：虽然你刚才来过我这里了，但是抱歉我不记得你来过了，而你还没办法证明自己来过！这就是很尴尬了，没办法啊我们现在随着发展需要记录事务了呀，这时我们会话技术就诞生了！会话的总体思想：令牌，既然你每次都不记得我，那好我们打造一个令牌分成两半，你一半我一半合的起来那就是对的人！不过发这半块令牌给你的人，还是服务端哦！</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><blockquote><p>Cookie 是客户端使用的一种记录客户端状态的机制，是<strong>由 W3C 组织提出</strong>，最早由 Netscape(网景) 社区发展的一种机制。目前 Cookie 已经成为标准，所有的主流浏览器基本都支持 Cookie 。Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#HTTP_is_stateless_but_not_sessionless" target="_blank" rel="noopener">无状态</a>的 HTTP 协议记录稳定的状态信息成为了可能。<strong>Cookie 实际上就是一小段文本信息</strong>。</p></blockquote><p>客户端请求服务器端，服务器端会在 HTTP 响应消息报头当中插入 Set-cookie ，存储的就是 Cookie 的值。</p><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g68v87xx0pj216n0pitbs.jpg" alt></p><p>客户端就会把 Cookie 保存起来，如果 Cookie 设置了过期时间那么就属于持久存储直到过期，如果没有设置过期时间浏览器关闭即为销毁，持久存储会存储在磁盘当中，非持久存储会存储在内存当中！</p><p>客户端下次在请求服务器端的时候，会自动在请求报头当中插入 Cookie 。服务器端检测该 Cookie，以此来识别用户状态。</p><p><img src="https://i.loli.net/2019/08/22/jPSrYbs8qJAUtlW.png" alt></p><p><img src="https://i.loli.net/2020/02/16/OcCHqx9ki12f5Lj.png" alt="123456.png"></p><h3 id="Cookie-细节"><a href="#Cookie-细节" class="headerlink" title="Cookie 细节"></a>Cookie 细节</h3><p>Cookie 基于浏览器本地存储数据，因此，只有在保存了 Cookie 的那个浏览器上能够使用该 Cookie。<strong>同一设备不同浏览器之间，Cookie 不通用。</strong></p><p>Cookie 的存储大小有限制：4KB 左右，每次请求都要进行网络传输，占用带宽。一个浏览器最多允许 300 个 Cookie 一个网站最多储存 20 个 Cookie，由于 Cookie 是存在客户端上的，所以浏览器加入了一些限制确保 Cookie 不会被恶意使用。</p><p>Cookie 的同源策略：Cookie 同样也有同源策略，不过与 AJAX 略微不用。AJAX 需要完全同源，而 Cookie 只需要同一父级域名即可。 比如： 请求 qq.com 下的资源时，会带上 qq.com 对应的 Cookie，不会带上 baidu.com 的 Cookie； 请求 v.qq.com 下的资源时，浏览器不仅会带上 v.qq.com 的 Cookie，还会带上 qq.com 的 Cookie 。在这里，qq.com 就是 v.qq.com 的父级域名</p><p>Cookie主要用于以下三个方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><p>Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API" target="_blank" rel="noopener">Web storage API</a> （本地存储和会话存储）或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">IndexedDB</a> 。</p><p>因为 Cookie 存储在客户端而客户端，即可见即不安全的原则，Cookie 容易被别有用心的人利用对自己的站点发起攻击，如：XSS，CSRF，都是利用的 Cookie 发起的攻击。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><blockquote><p>Session 是服务器端使用的一种记录客户端状态的机制，使用上比 Cookie 简单一些，相应的也增加了服务器的存储压力。不同于 Cookie 的是， Session 是保存在服务器端的。其实 Session 的实现最终还是 Cookie 。当我们用 Session 时，服务器端返回却是一段 Cookie 。从而可以说 Session 的实现依赖 Cookie。</p></blockquote><p>客户端访问服务器端，如果会使用到 Session，那么服务器端在 HTTP 响应报头当中会插入 Set-Cookie ,而这段 Cookie 记录着什么呢？记录着 SeesionID 。</p><p><img src="https://i.loli.net/2019/08/22/VDNZKPlfM5mu7bw.png" alt></p><p>客户端再次请求服务器端的时候，在 HTTP 请求报头当中自动插入 Cookie(Cookie 的值也就是 SeesionID)，服务器端拿到 Cookie 之后，读取当中的 SeesionID，会自动去寻找到这个 Session 文件所存放的位置（ PHP 当中 Session 属于持久存储在磁盘当中，默认 24 分钟之后删除数据，删除的是数据而不是删除这个 Session 文件）读取数据。在 PHP 当中默认的就是浏览器关闭， SessionID 销毁。</p><p><img src="https://i.loli.net/2019/08/22/dVJRSygoAp6ksu2.png" alt></p><p><img src="https://i.loli.net/2020/02/16/NvZuei68fsP9IBh.png" alt="是打算打算的.png"></p><p>以下是 PHP Seesion 的配置</p><pre><code>session.save_path = &quot;/home/jialaolian/Desktop/Session&quot;#这个就是你session存放的地址session.use_cookies=1#把这个的值设置为1，利用cookie来传递sessionidsession.cookie_lifetime=0#这个代表SessionID在客户端Cookie储存的时间，默认是0，代表浏览器一关闭SessionID就销毁session.gc_maxlifetime=1440#这个是Session数据在服务器端储存的时间，如果超过这个时间，那么Session数据就自动删除！</code></pre><h3 id="Session-细节"><a href="#Session-细节" class="headerlink" title="Session 细节"></a>Session 细节</h3><p>面试题当中经常会出现禁用了 Cookie 之后 Session 还可以用嘛？</p><p>答案：可以！</p><p>session 实现关键是 sessionID，只需要将 sessionID 传递给浏览器，浏览器在请求的时候再将 sessionID 传递给服务器，就可以实现 session。所以，可以使用在 URL 中插入查询参数的方式来实现 sessionID 的传递。</p><p>假如你使用了 Nginx 服务器软件做了负载均衡，那么你会发现丢失 Session 的问题。出现丢失 Session 问题呢，我们可以使用用 Nginx ip_hash 算法解决。</p><h3 id="Session-和-Cookie-的区别"><a href="#Session-和-Cookie-的区别" class="headerlink" title="Session 和 Cookie 的区别"></a>Session 和 Cookie 的区别</h3><ul><li>session 在服务器端，cookie 在客户端。</li><li>session 用户无法查看和修改，cookie 用户可以查看修改。</li><li>session 和 cookie 的存储容量不同。</li><li>session 的实现依赖于 sessionID，而 sessionID 又存储在 cookie 上，所以，可以这么说：session 是基于 cookie 实现的一种数据存储方式。</li><li>他们共同点，因为 Session 需要依赖 Cookie 所以 XSS 与 CSRF 对他们都有效。 </li><li>Cookie 只能存储字符串，而且 Session 不限制。</li></ul><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><blockquote><p>Token 我们的中文翻译‘令牌’</p></blockquote><h6 id="Token-的引入："><a href="#Token-的引入：" class="headerlink" title="Token 的引入："></a>Token 的引入：</h6><p>Token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token 便应运而生。</p><h6 id="Token-的定义："><a href="#Token-的定义：" class="headerlink" title="Token 的定义："></a>Token 的定义：</h6><p>Token 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个 Token 便将此 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码。</p><h6 id="使用-Token-的目的："><a href="#使用-Token-的目的：" class="headerlink" title="使用 Token 的目的："></a>使用 Token 的目的：</h6><p>Token 的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p><h6 id="Token-的优点："><a href="#Token-的优点：" class="headerlink" title="Token 的优点："></a>Token 的优点：</h6><p>扩展性更强，也更安全点，非常适合用在 Web 应用或者移动应用上。Token 的中文有人翻译成 “令牌”，我觉得挺好，意思就是，你拿着这个令牌，才能过一些关卡。</p><h6 id="Token-一般用在三个地方"><a href="#Token-一般用在三个地方" class="headerlink" title="Token 一般用在三个地方:"></a>Token 一般用在三个地方:</h6><p>①防止表单重复提交<br>②anti csrf 攻击（跨站点请求伪造）<br>③身份验证（单点登录）</p><p>Token 类似与 HTTP 协议当中的<strong>无状态</strong>特性，他不需要在服务器端保留用户的认证信息或者会话信息。这就意味着基于 Token 认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p><p>流程上是这样的：</p><ul><li>用户使用用户名密码来请求服务器</li><li>服务器进行验证用户的信息</li><li>服务器通过验证发送给用户一个 token</li><li>客户端存储 token，并在每次请求时附送上这个 token 值</li><li>服务端验证 token 值，并返回数据</li></ul><blockquote><p>原文地址：</p><p><a href="https://blog.csdn.net/cmj6706/article/details/79032703" target="_blank" rel="noopener">https://blog.csdn.net/cmj6706/article/details/79032703</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 会话技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 会话技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议简单理解</title>
      <link href="/2019/08/11/HTTP%E5%8D%8F%E8%AE%AE%E7%90%86%E8%A7%A3/"/>
      <url>/2019/08/11/HTTP%E5%8D%8F%E8%AE%AE%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="简述历史"><a href="#简述历史" class="headerlink" title="简述历史"></a>简述历史</h2><blockquote><p>HTTP 协议(超文本传输协议 HyperText Transfer Protocol )，它是基于 TCP/IP 协议的应用层传输协议，简单来说就是客户端和服务端进行数据传输的一种规则。默认使用 80 端口。</p><p>HTTP 协议工作于客户端-服务端架构之上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。 WEB 服务器根据接收到的请求后，向客户端发送响应信息。</p><blockquote><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g654ktgyvbj20fb051dfr.jpg" alt></p></blockquote><p>1991年发布的 HTTP/0.9 版本发布，该版本及其的简单，只有一个命令 GET 。</p><p>1996年5月份， HTTP/1.0 版本发布，内容大大的增加。首先可以发送任何格式的内容，除了传输文字，还可以传送图片、视频、二进制文件。其次除了GET 命令，还引入了 POST 和 HEAD 命令也就是我们说的简单请求方式。1.0 版本缺点无法做到持久连接，造成大量的通信开销。</p><p>1997年1月，HTTP/1.1 版本发布，他进一步的完善了 HTTP 协议，目前来说我们用的最多的还是 HTTP/1.1 版本。1.1 版本最大的变化就是引入了持久连接，只要 TCP 链接默认不关闭，那么他就可以一直复用。不用声明 Connection: keep-alive，目前，对于同一个域名，大多数浏览器允许同时建立 6 个持久连接。</p><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3 。3 版本的最大的改变，可能会抛弃掉 TCP 协议使用 UDP 协议。</p></blockquote><h2 id="TCP-协议简述"><a href="#TCP-协议简述" class="headerlink" title="TCP 协议简述"></a>TCP 协议简述</h2><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g5w31tlidzj20o10hbgpo.gif" alt></p><blockquote><p>建立 TCP 需要三次捂手建立连接，与四次挥手断开连接。整个过程如下图：</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g658ctyl3jj20f60lct9v.jpg" alt></p><h3 id="TCP-三次捂手"><a href="#TCP-三次捂手" class="headerlink" title="TCP 三次捂手"></a>TCP 三次捂手</h3><p>首先客户端发送连接请求报文，服务端接收连接后回复 ACK 报文，并为这次连接分配资源。客户端接收到 ACK 报文后也向服务端发送 ACK 报文，并分配资源，这样 TCP 连接就建立了。其实所谓的三次捂手其实就是建立一个 TCP 连接时，需要客户端和服务端总共发送三个包，三次捂手的目的是个连接服务器指定的端口，建立 TCP 连接，并同步连接双方的序列号和确认并交换 TCP 窗口大小信息，在 SOCKET 编程当中，客户端执行 connect() 时，将会触发三次捂手：</p><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g658o2qh0ij20f109374f.jpg" alt></p><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>TCP 连接的拆除需要发送四个包，客户端或者服务器端均可主动发起挥手动作，在 SOCKET 编程中，任何一方执行 close() 即可产生挥手操作。假设客户端发起中断连接请求，就先发送 FIN 报文。服务端接到 FIN 报文后，但是如果还有数据没有发送完成，则不必急着关闭 Socket ，可以继续发送数据。所以服务器端先发送 ACK ，告诉客户端：请求已经收到了，但是我还没准备好，请继续等待停止的消息。这个时候客户端就进入 FIN_WAIT 状态，继续等待服务端的 FIN 报文。当服务端确定数据已发送完成，则向客户端发送 FIN 报文，告诉客户端：服务器这边数据发完了，准备好关闭连接了。客户端收到 FIN 报文后，就知道可以关闭连接了，但是他还是不相信网络，所以发送 ACK 后进入 TIME_WAIT 状态， 服务端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL 后依然没有收到回复，则证明服务端已正常关闭，最后，客户端也可以关闭连接了至此， TCP 连接就已经完全关闭了！关闭连接的过程如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g658xy3fgrj20by085dfx.jpg" alt></p><h2 id="HTTP-工作流程"><a href="#HTTP-工作流程" class="headerlink" title="HTTP 工作流程"></a>HTTP 工作流程</h2><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w3bsgdqmj20fy06o75n.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w3f1g673j20kh09cdiv.jpg" alt></p><h2 id="HTTP-协议的特点"><a href="#HTTP-协议的特点" class="headerlink" title="HTTP 协议的特点"></a>HTTP 协议的特点</h2><ul><li>支持客户/服务器模式：请求 响应</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种 方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li><li>灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。早期这么做的原因是请求资源少，追求快。后来通过 Connection: Keep-Alive 实现长连接</li><li>无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ul><p>HTTP 是一种无状态协议，HTTP 协议本身不会对发送过来的请求和响应的通信状态做一个持久化处理。这样做的目的就是为了保证 HTTP 协议的简单性，从而能够快速的处理大量的事务，提高效率。</p><p>然而在很多的场景当中，无状态的特性就让我们非常尴尬，比如说我们需要保持一个用户登录状态，由于我们 HTTP 协议无状态的特点，无法向服务器证明我们’认识’，所以我们需要引入别的技术来做处理。比如：cookie</p><h2 id="HTTP-URL"><a href="#HTTP-URL" class="headerlink" title="HTTP URL"></a>HTTP URL</h2><pre class="line-numbers language-php"><code class="language-php">http<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//host[":"port][abs_path]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>host: 代表主机域名或IP地址</li><li>port: 端口号，缺省端口80</li><li>abs_path : 请求资源的URL，如果没有，填 “/“，通常浏览器会帮我们自动完成。<br>EG:</li><li>举个栗子：<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> </li></ul><h2 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h2><p>下图是在网上找的一张图，觉得能很好的表达HTTP请求的所发送的数据格式。</p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w3ngr7gfj20kr06lmx0.jpg" alt></p><p>由上图可以看到，HTTP 请求由请求行，消息报头，请求正文三部分构成。</p><h3 id="HTTP-请求状态行"><a href="#HTTP-请求状态行" class="headerlink" title="HTTP 请求状态行"></a>HTTP 请求状态行</h3><p>请求行由请求 Method ,  URL 字段和 HTTP Version 三部分构成, 总的来说请求行就是定义了本次请求的请求方式, 请求的地址, 以及所遵循的 HTTP 协议版本例如：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token constant">GET</span> <span class="token operator">/</span>example<span class="token punctuation">.</span>html <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token function">1</span> <span class="token punctuation">(</span><span class="token constant">CRLF</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>HTTP 协议的方法有：</p><ul><li>GET： 请求*<em>获取 *</em>Request-URI 所标识的资源</li><li>POST： 在 Request-URI 所标识的资源后<strong>增加</strong>新的数据</li><li>HEAD： 请求获取由 Request-URI 所标识的资源的<strong>响应消息报头</strong></li><li>PUT： 请求服务器<strong>存储或修改</strong>一个资源，并用 Request-URI 作为其标识</li><li>DELETE： 请求服务器*<em>删除 *</em>Request-URI 所标识的资源</li><li>TRACE： 请求服务器回送收到的请求信息，主要用于<strong>测试或诊断</strong></li><li>CONNECT： 保留将来使用</li><li>OPTIONS： 请求查询服务器的性能，或者查询与资源相关的选项和需求</li></ul><h3 id="HTTP-请求头"><a href="#HTTP-请求头" class="headerlink" title="HTTP 请求头"></a>HTTP 请求头</h3><p>消息报头由一系列的键值对组成，允许客户端向服务器端发送一些附加信息或者客户端自身的信息，主要包括：</p><table><thead><tr><th>Header</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>Accept</td><td>告诉服务器，客户端支持的数据类型。</td><td>Accept: text/plain, text/html</td></tr><tr><td>Accept-Charset</td><td>告诉服务器，客户端采用的编码。</td><td>Accept-Charset: iso-8859-5,utf-8</td></tr><tr><td>Accept-Encoding</td><td>告诉服务器，客户机支持的数据压缩格式。</td><td>Accept-Encoding: compress, gzip</td></tr><tr><td>Accept-Language</td><td>告诉服务器，客户机的语言环境。</td><td>Accept-Language: en,zh</td></tr><tr><td>Accept-Ranges</td><td>可以请求网页实体的一个或者多个子范围字段</td><td>Accept-Ranges: bytes</td></tr><tr><td>Authorization</td><td>HTTP授权的授权证书类型</td><td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td>Cache-Control</td><td>指定请求和响应遵循的缓存机制</td><td>Cache-Control: no-cache</td></tr><tr><td>Connection</td><td>表示是否需要持久连接（HTTP 1.1默认进行持久连接）</td><td>Keep-Alive</td></tr><tr><td>Cookie</td><td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器</td><td>Cookie: $Version=1; Skin=new;</td></tr><tr><td>Content-Length</td><td>请求的内容长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Type</td><td>请求的与实体对应的MIME信息</td><td>Content-Type: application/x-www-form-urlencoded</td></tr><tr><td>Date</td><td>请求发送的日期和时间</td><td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td></tr><tr><td>Expect</td><td>请求的特定的服务器行为</td><td>Expect: 100-continue</td></tr><tr><td>From</td><td>发出请求的用户的Email</td><td>From: <a href="mailto:xxx@163.com" target="_blank" rel="noopener">xxx@163.com</a></td></tr><tr><td>Host</td><td>指定请求的服务器的域名和端口号</td><td>Host: <a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.zcmhi.com" target="_blank" rel="noopener">www.baidu.com</a></td></tr><tr><td>If-Match</td><td>只有请求内容与实体相匹配才有效</td><td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Modified-Since</td><td>客户机通过这个头告诉服务器，资源的缓存时间。</td><td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td></tr><tr><td>If-None-Match</td><td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td><td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Range</td><td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td><td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Unmodified-Since</td><td>只在实体在指定时间之后未被修改才请求成功</td><td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td></tr><tr><td>Max-Forwards</td><td>限制信息通过代理和网关传送的时间</td><td>Max-Forwards: 10</td></tr><tr><td>Pragma</td><td>用来包含实现特定的指令</td><td>Pragma: no-cache</td></tr><tr><td>Proxy-Authorization</td><td>连接到代理的授权证书</td><td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td>Range</td><td>只请求实体的一部分，指定范围</td><td>Range: bytes=500-999</td></tr><tr><td>Referer</td><td>客户机通过这个头告诉服务器，它是从哪个资源来访问服务器的。（一般用于防盗链）</td><td>Referer: <a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.zcmhi.com%2Farchives%2F71.html" target="_blank" rel="noopener">www.zcmhi.com/archives/71…</a></td></tr><tr><td>TE</td><td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td><td>TE: trailers,deflate;q=0.5</td></tr><tr><td>Upgrade</td><td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td><td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td></tr><tr><td>User-Agent</td><td>浏览器的具体信息</td><td>User-Agent: Mozilla/5.0 (Linux; X11)</td></tr><tr><td>Via</td><td>通知中间网关或代理服务器地址，通信协议</td><td>Via: 1.0 fred, 1.1 <a href="https://link.juejin.im/?target=http%3A%2F%2Fnowhere.com" target="_blank" rel="noopener">nowhere.com</a>(Apache/1.1)</td></tr><tr><td>Warning</td><td>关于消息实体的警告信息</td><td>Warn: 199 Miscellaneous warning</td></tr></tbody></table><h3 id="HTTP-请求正文"><a href="#HTTP-请求正文" class="headerlink" title="HTTP 请求正文"></a>HTTP 请求正文</h3><p>只有发送 POST 方式时才有请求正文，GET 方式没有请求正文</p><h3 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h3><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w4vnbdrvj20m80egaan.jpg" alt></p><h2 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h2><p>与 HTTP 请求类似，先上一张图：</p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w4wab05kj20kp06qt8k.jpg" alt></p><p>HTTP 响应也由三部分组成，包括状态行，消息报头，响应正文。</p><h3 id="HTTP-响应状态行"><a href="#HTTP-响应状态行" class="headerlink" title="HTTP 响应状态行"></a>HTTP 响应状态行</h3><p>状态行也由三部分组成，包括 HTTP 协议的版本，状态码，以及对状态码的文本描述。例如：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">200</span> <span class="token constant">OK</span> （<span class="token constant">CRLF</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="HTTP-响应头"><a href="#HTTP-响应头" class="headerlink" title="HTTP 响应头"></a>HTTP 响应头</h3><table><thead><tr><th align="left">Header</th><th align="left">解释</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">Accept-Ranges</td><td align="left">表明服务器是否支持指定范围请求及哪种类型的分段请求</td><td align="left">Accept-Ranges: bytes</td></tr><tr><td align="left">Age</td><td align="left">从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td><td align="left">Age: 12</td></tr><tr><td align="left">Allow</td><td align="left">对某网络资源的有效的请求行为，不允许则返回405</td><td align="left">Allow: GET, HEAD</td></tr><tr><td align="left">Cache-Control</td><td align="left">告诉所有的缓存机制是否可以缓存及哪种类型</td><td align="left">Cache-Control: no-cache</td></tr><tr><td align="left">Content-Encoding</td><td align="left">web服务器支持的返回内容压缩编码类型。</td><td align="left">Content-Encoding: gzip</td></tr><tr><td align="left">Content-Language</td><td align="left">响应体的语言</td><td align="left">Content-Language: en,zh</td></tr><tr><td align="left">Content-Length</td><td align="left">响应体的长度</td><td align="left">Content-Length: 348</td></tr><tr><td align="left">Content-Location</td><td align="left">请求资源可替代的备用的另一地址</td><td align="left">Content-Location: /index.htm</td></tr><tr><td align="left">Content-MD5</td><td align="left">返回资源的MD5校验值</td><td align="left">Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td></tr><tr><td align="left">Content-Range</td><td align="left">在整个返回体中本部分的字节位置</td><td align="left">Content-Range: bytes 21010-47021/47022</td></tr><tr><td align="left">Content-Type</td><td align="left">如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码</td><td align="left">Content-Type: text/html; charset=utf-8</td></tr><tr><td align="left">Date</td><td align="left">原始服务器消息发出的时间</td><td align="left">Date: Tue, 15 Nov 2010 08:12:31 GMT</td></tr><tr><td align="left">ETag</td><td align="left">请求变量的实体标签的当前值</td><td align="left">ETag: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td align="left">Expires</td><td align="left">响应过期的日期和时间</td><td align="left">Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr><tr><td align="left">Last-Modified</td><td align="left">请求资源的最后修改时间</td><td align="left">Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td></tr><tr><td align="left">Location</td><td align="left">用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td><td align="left">Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td align="left">Pragma</td><td align="left">包括实现特定的指令，它可应用到响应链上的任何接收方</td><td align="left">Pragma: no-cache</td></tr><tr><td align="left">Proxy-Authenticate</td><td align="left">它指出认证方案和可应用到代理的该URL上的参数</td><td align="left">Proxy-Authenticate: Basic</td></tr><tr><td align="left">refresh</td><td align="left">应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td><td align="left">Refresh: 5; url=<a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td align="left">Retry-After</td><td align="left">如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td><td align="left">Retry-After: 120</td></tr><tr><td align="left">Server</td><td align="left">web服务器软件名称</td><td align="left">Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td></tr><tr><td align="left">Set-Cookie</td><td align="left">设置Http Cookie</td><td align="left">Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td></tr><tr><td align="left">Trailer</td><td align="left">指出头域在分块传输编码的尾部存在</td><td align="left">Trailer: Max-Forwards</td></tr><tr><td align="left">Transfer-Encoding</td><td align="left">文件传输编码</td><td align="left">Transfer-Encoding:chunked</td></tr><tr><td align="left">Vary</td><td align="left">告诉下游代理是使用缓存响应还是从原始服务器请求</td><td align="left">Vary: *</td></tr><tr><td align="left">Via</td><td align="left">告知代理客户端响应是通过哪里发送的</td><td align="left">Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td></tr><tr><td align="left">Warning</td><td align="left">警告实体可能存在的问题</td><td align="left">Warning: 199 Miscellaneous warning</td></tr><tr><td align="left">WWW-Authenticate</td><td align="left">表明客户端请求实体应该使用的授权方案</td><td align="left">WWW-Authenticate: Basic</td></tr></tbody></table><h3 id="HTTP-响应状态码"><a href="#HTTP-响应状态码" class="headerlink" title="HTTP 响应状态码"></a>HTTP 响应状态码</h3><p>状态代码有三位数字组成，第一个数字定义了响应的<strong>类别</strong>，且有五种可能取值：</p><ul><li><p>1xx：<strong>指示信息</strong> - 表示请求已接收，继续处理</p></li><li><p>100 客户必须继续发出请求</p><ul><li>101 客户要求服务器根据请求转换 HTTP 协议版本</li></ul></li><li><p>2xx：<strong>成功</strong> - 表示请求已被成功接收、理解、接受</p></li><li><p>200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</p><ul><li>201 （已创建） 请求成功并且服务器创建了新的资源。</li><li>202 （已接受） 服务器已接受请求，但尚未处理。</li></ul></li><li><p>3xx：<strong>重定向</strong> - 要完成请求必须进行更进一步的操作</p></li><li><p>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p></li><li><p>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</p><ul><li>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li></ul></li><li><p>4xx：<strong>客户端错误</strong> - 请求有语法错误或请求无法实现</p></li><li><p>400 （错误请求） 服务器不理解请求的语法。</p><ul><li>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li><li>403 （禁止） 服务器拒绝请求。</li></ul></li><li><p>5xx：<strong>服务器端错误</strong> - 服务器未能实现合法的请求</p></li><li><p>500 （服务器内部错误） 服务器遇到错误，无法完成请求。</p></li><li><p>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</p></li><li><p>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</p></li><li><p>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</p></li><li><p>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p></li><li><p>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p></li></ul><h3 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h3><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w50fsridj20m80g7jrx.jpg" alt></p><h2 id="非持久连接和持久连接"><a href="#非持久连接和持久连接" class="headerlink" title="非持久连接和持久连接"></a>非持久连接和持久连接</h2><p>在实际的应用当中，客户端往往会发送一系列的请求，接着服务器端一一的响应。对于这些请求|响应，如果每次都经过一个单独的 TPC 连接发送，称为非持久链接。反之，如果每次都经过相同的 TCP 连接进行发送，称为持久链接</p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w5876x3xj20hi0cjglu.jpg" alt></p><p>非持久连接在每次的请求|响应之后就会断开连接，下次在重新建立新的 TCP 链接，这样就会造成大量的通信开销。例如前面提到的往返时间( RTT ) 就是在建立 TCP 连接的过程中的代价。</p><p>非持久连接给服务器带来了沉重的负担，每台服务器可能同时面对数以百计甚至更多的请求。持久连接就是为了解决这些问题，其特点是一直保持 TCP 连接状态，直到遇到明确的中断要求之后再中断连接。持久连接减少了通信开销，节省了通信量。</p><h2 id="GET-与-POST-请求之间的区别"><a href="#GET-与-POST-请求之间的区别" class="headerlink" title="GET 与 POST 请求之间的区别"></a>GET 与 POST 请求之间的区别</h2><table><thead><tr><th align="center">区别内容</th><th align="center">GET</th><th align="center">POST</th></tr></thead><tbody><tr><td align="center">点击返回/刷新按钮</td><td align="center">没有影响</td><td align="center">数据会重新发送（浏览器将会提示“数据被重新提交”）</td></tr><tr><td align="center">添加书签</td><td align="center">可以</td><td align="center">不可以</td></tr><tr><td align="center">缓存</td><td align="center">可以</td><td align="center">不可以</td></tr><tr><td align="center">编码类型（Encoding type）</td><td align="center">application/x-www-form-rulencoded</td><td align="center"><code>application/x-www-form-rulencoded</code> or <code>multipart/form-data</code> 请为二进制数据使用 <code>multipart</code> 编码</td></tr><tr><td align="center">历史记录</td><td align="center">有</td><td align="center">没有</td></tr><tr><td align="center">长度限制</td><td align="center">有</td><td align="center">没有</td></tr><tr><td align="center">数据类型限制</td><td align="center">只允许 ASCLll 字符类型</td><td align="center">没有限制，允许二进制数据</td></tr><tr><td align="center">安全性</td><td align="center">查询字符串会显示在地址栏的 URL 上，不安全，<strong>请不要使用 GET 请求提交敏感数据</strong></td><td align="center">因为数据不会显示在地址栏中，也不会缓存下来或保存在浏览记录中，所以 POST 请求比 GET 请求安全，但也不是最安全的方式，如需要传送敏感数据，<strong>请使用数据加密</strong>。</td></tr><tr><td align="center">可见性</td><td align="center">查询字符串在地址栏的 URL 中可见</td><td align="center">查询字符串在地址栏的 URL 中不可见</td></tr></tbody></table><h2 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h2><h3 id="HTTP-的不足"><a href="#HTTP-的不足" class="headerlink" title="HTTP 的不足"></a>HTTP 的不足</h3><ul><li>通信使用明文(不加密),内容可能会被窃听</li><li>不验证通信方的身份,因此有可能遭遇伪装</li><li>无法证明报文的完整性,所以有可能已遭篡改</li></ul><h3 id="HTTPS-介绍"><a href="#HTTPS-介绍" class="headerlink" title="HTTPS 介绍"></a>HTTPS 介绍</h3><p>HTTP 协议中没有加密机制,但可以通 过和 SSL (Secure Socket Layer, <strong>安全套接层</strong> )或 TLS (Transport Layer Security, <strong>安全层传输协议</strong>)的组合使用,加密 HTTP 的通信内容。属于通信加密，即在整个通信线路中加密。</p><pre class="line-numbers language-text"><code class="language-text">HTTP + 加密 + 认证 + 完整性保护 = HTTPS（HTTP Secure ）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w5c2yjgaj20m80anwec.jpg" alt></p><p>HTTPS 采用<strong>共享密钥加密</strong>（对称）和<strong>公开密钥加密</strong>（非对称）两者并用的<strong>混合</strong>加密机制。若密钥能够实现安全交换,那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比,其处理速度要慢。</p><blockquote><p>所以应充分利用两者各自的优势, 将多种方法组合起来用于通信。 在<strong>交换密钥</strong>阶段使用<strong>公开密钥加密</strong>方式,之后的建立通信<strong>交换报文</strong>阶段 则使用<strong>共享密钥加密</strong>方式。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w5dby1hrj20m80fz0tb.jpg" alt></p><p><code>HTTPS</code>握手过程的简单描述如下：</p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w5dv56z8j20m80det9g.jpg" alt></p><ol><li><p>浏览器将自己支持的一套加密规则发送给网站。</p><pre><code>服务器获得浏览器公钥</code></pre></li><li><p>网站从中选出一组加密算法与 HASH 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</p><pre><code>浏览器获得服务器公钥</code></pre></li><li><p>获得网站证书之后浏览器要做以下工作：</p><p>(a). 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。</p><p>(b). 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码（接下来通信的密钥），并用证书中提供的公钥加密（共享密钥加密）。</p><p>(c) 使用约定好的 HASH 计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</p><pre><code>  浏览器验证 -&gt; 随机密码  服务器的公钥加密 -&gt; 通信的密钥  通信的密钥 -&gt; 服务器</code></pre></li><li><p>网站接收浏览器发来的数据之后要做以下的操作：</p><p>(a). 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证 HASH 是否与浏览器发来的一致。</p><p>(b). 使用密码加密一段握手消息，发送给浏览器。</p><pre><code>  服务器用自己的私钥解出随机密码 -&gt; 用密码解密握手消息（共享密钥通信）-&gt; 验证HASH与浏览器是否一致（验证浏览器）</code></pre></li></ol><h3 id="HTTPS-的不足"><a href="#HTTPS-的不足" class="headerlink" title="HTTPS 的不足"></a>HTTPS 的不足</h3><ul><li>加密解密过程复杂，导致访问速度慢</li><li>加密需要认向证机构付费</li><li>整个页面的请求都要使用 HTTPS</li></ul><blockquote><p>参考地址：</p><p><a href="https://www.cnblogs.com/quan-coder/p/9277837.html" target="_blank" rel="noopener">https://www.cnblogs.com/quan-coder/p/9277837.html</a></p><p><a href="https://juejin.im/post/5ba65296f265da0ac8493503" target="_blank" rel="noopener">https://juejin.im/post/5ba65296f265da0ac8493503</a></p><p><a href="https://juejin.im/post/5d0de954e51d4556be5b3a6f" target="_blank" rel="noopener">https://juejin.im/post/5d0de954e51d4556be5b3a6f</a></p><p><a href="http://swiftlet.net/archives/1082" target="_blank" rel="noopener">http://swiftlet.net/archives/1082</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-处理跨域请求</title>
      <link href="/2019/08/07/Laravel-%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
      <url>/2019/08/07/Laravel-%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>出于安全性的原因，浏览器会限制 Script 中的跨域请求。由于 XMLHttpRequest 遵循同源策略，所有使用 XMLHttpRequest 构造 HTTP 请求的应用只能访问自己的域名，如果需要构造跨域的请求，那么开发者需要配合浏览器做出一些允许跨域的配置。</p><p>在前后端分离的应用中，需要使用 CORS 完成跨域访问。在 CORS中 发送<strong>非简单请求</strong>（简单请求也就是 GET、POST、HEAD，非简单请求：PUT、DELETE等）时，前端会发一个请求方式为 OPTIONS 的预请求，前端只有收到服务器对这个 OPTIONS 请求的正确响应，才会发送正常的请求，否则将抛出跨域相关的错误。</p><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>首先需要了解一下浏览器 <a href="https://baike.baidu.com/item/同源策略" target="_blank" rel="noopener">同源策略</a>，它是浏览器最核心也最基本的安全功能，同源的意思是，域名，协议，端口都相同。如果两个地址不同源，那么：</p><ol><li>Cookie、LocalStorage 和 IndexDB 无法相互读取；</li><li>DOM 无法相互获得；</li><li>AJAX 请求不能相互发送。</li></ol><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS 是一个 W3C 标准，全称是 “跨域资源共享”（Cross-origin resource sharing），就是其中一种用来解决浏览器跨域的问题方法。这种方法的关键是在于服务器，只要服务器端返回了合适的头信息（Header），前端 JS 发送 AJAX 的时候就能访问跨域的资源，代码和同源时一致，无需做任何修改，用户也不会有感知。</p><ul><li>响应的头部应该追加 Access-Control-Allow-Orign，用来表明哪些请求源被允许访问资源内容</li><li>浏览器会对请求源和响应中的值进行匹配验证</li><li>对于跨域的请求，浏览器会预发送一个非简单方式的请求，来判断给定资源是否准备接受跨域资源访问</li><li>服务端应用通过检查请求头部的 Orign 来判定请求是否跨域。</li></ul><h3 id="使用-laravel-扩展包处理跨域请求"><a href="#使用-laravel-扩展包处理跨域请求" class="headerlink" title="使用 laravel 扩展包处理跨域请求"></a>使用 laravel 扩展包处理跨域请求</h3><blockquote><p>barryvdh/laravel-cors：<a href="https://packagist.org/packages/barryvdh/laravel-cors" target="_blank" rel="noopener">https://packagist.org/packages/barryvdh/laravel-cors</a>  </p><p>他是一个已经写好了的扩展包，唯一的功能就是帮我们解决跨域请求问题，使用也非常的简单</p></blockquote><h3 id="1、composer-安装扩展包"><a href="#1、composer-安装扩展包" class="headerlink" title="1、composer 安装扩展包"></a>1、composer 安装扩展包</h3><pre><code>$ composer require barryvdh/laravel-cors</code></pre><blockquote><p>Laravel 5.5 及以上版本支持自动包发现，无需注册服务提供者，Laravel 5.4 及以下版本需要手动在 config/app.php 中注册服务提供者</p></blockquote><h3 id="2、发布配置文件"><a href="#2、发布配置文件" class="headerlink" title="2、发布配置文件"></a>2、发布配置文件</h3><pre><code>$ php artisan vendor:publish --provider=&quot;Barryvdh\Cors\ServiceProvider&quot;</code></pre><blockquote><p>在我们的 config 目录下面会生成一个 cors.php 的配置文件</p></blockquote><h3 id="3、注册全局中间或路由中间"><a href="#3、注册全局中间或路由中间" class="headerlink" title="3、注册全局中间或路由中间"></a>3、注册全局中间或路由中间</h3><blockquote><p><em>app/Http/Kernel.php</em> </p><p> 下面注册全局中间件或者路由中间件</p></blockquote><pre><code>    protected $middleware = [        \Barryvdh\Cors\HandleCors::class, # cors 跨域处理全局中间件    ];</code></pre><pre><code>    protected $routeMiddleware = [        &#39;cors&#39; =&gt; \Barryvdh\Cors\HandleCors::class, # cors 跨域处理路由中间件    ];</code></pre><h3 id="4、自定义配置"><a href="#4、自定义配置" class="headerlink" title="4、自定义配置"></a>4、自定义配置</h3><p>可以看到只要使用了中间件，所有的请求都是可以通过的，也就是说，barryvdh/laravel-cors 的默认配置都是允许所有请求，当然我们可以修改这些配置：</p><p><em>config/cors.php</em></p><pre><code>    &#39;supportsCredentials&#39; =&gt; false,    &#39;allowedOrigins&#39; =&gt; [&#39;*&#39;],    &#39;allowedOriginsPatterns&#39; =&gt; [],    &#39;allowedHeaders&#39; =&gt; [&#39;*&#39;],    &#39;allowedMethods&#39; =&gt; [&#39;*&#39;],    &#39;exposedHeaders&#39; =&gt; [],    &#39;maxAge&#39; =&gt; 0,</code></pre><p>分别对应如下配置：</p><table><thead><tr><th>配置</th><th>对应的 Header</th><th>说明</th></tr></thead><tbody><tr><td>supportsCredentials</td><td>Access-Control-Allow-Credentials</td><td>是否携带 Cookie</td></tr><tr><td>allowedOrigins</td><td>Access-Control-Allow-Origin</td><td>允许的域名</td></tr><tr><td>allowedOriginsPatterns</td><td>Access-Control-Allow-Origin</td><td>通过正则匹配允许的域名</td></tr><tr><td>allowedHeaders</td><td>Access-Control-Allow-Headers</td><td>允许的 Header</td></tr><tr><td>allowedMethods</td><td>Access-Control-Allow-Methods</td><td>允许的 HTTP 方法</td></tr><tr><td>exposedHeaders</td><td>Access-Control-Expose-Headers</td><td>除了 6 个基本的头字段，额外允许的字段</td></tr><tr><td>maxAge</td><td>Access-Control-Max-Age</td><td>预检请求的有效期</td></tr></tbody></table><blockquote><p>原文地址：</p><p><a href="https://learnku.com/courses/laravel-package/solving-cross-domain-problems-cors-barryvdhlaravel-cors/2026" target="_blank" rel="noopener">https://learnku.com/courses/laravel-package/solving-cross-domain-problems-cors-barryvdhlaravel-cors/2026</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manjaro</title>
      <link href="/2019/08/04/Manjaro%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/08/04/Manjaro%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Manjaro-Linux"><a href="#Manjaro-Linux" class="headerlink" title="Manjaro Linux"></a>Manjaro Linux</h2><p>最强大最牛逼最好的 Linux 桌面发行版本，不接受任何的反驳！！！我是 KDE ，其他版本感觉上面都没有 KDE舒服！反正我感觉是最好用的版本！！！</p><p>Linux 桌面系统排行榜：<a href="https://distrowatch.com/" target="_blank" rel="noopener">https://distrowatch.com/</a></p><p><img src="https://i.loli.net/2020/03/22/YeAo9rb6CFSyVW5.png" alt="深度截图_选择区域_20200322025652.png"></p><p><img src="https://i.loli.net/2019/10/11/GiH5keFqWfunK8c.jpg" alt></p><p><img src="https://i.loli.net/2020/03/22/1Zt5pTfmuqFvMhD.png" alt="Screenshot_20200322_171912.png"></p><blockquote><p>为什么会选择 Manjaro 这个发行版本呢？</p><p>1、滚动升级</p><p>2、自动硬件检测安装</p><p>3、先进的包管理、最多软件支持的 Linux 发行版本</p><p>4、超级高度用户自定义、桌面、主题、界面、文件、操作、显示等等，全部可用户自定义</p><p>5、软件版本超级牛逼的同步快，基本与各个软件的版本持平</p><p>6、目前生态最好的一款 Linux 桌面版本之一（在我心里是第一）</p><p>7、本地化相比 18.10 之前已经做的非常好了，我又倒腾了目前 19.0.2 的 KDE 版本</p><p>8、超级稳定</p></blockquote><h3 id="中科大软件源"><a href="#中科大软件源" class="headerlink" title="中科大软件源"></a>中科大软件源</h3><pre><code>1.选择源sudo pacman-mirrors -i -c China -m rank 运行一段时间后，会出现选择框，这里选择http://mirrors.ustc.edu.cn/manjaro2.刷新缓存sudo pacman -Syy3.修改配置文件sudo vim /etc/pacman.conf添加到末尾[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch4.导入 GPG Keysudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring</code></pre><h3 id="最好包管理"><a href="#最好包管理" class="headerlink" title="最好包管理"></a>最好包管理</h3><pre><code># 个人比较喜欢 yaourtsudo pacman -S yaourt# yay 也是一种选择sudo pacman -S yay</code></pre><h3 id="最强-Shell"><a href="#最强-Shell" class="headerlink" title="最强 Shell"></a>最强 Shell</h3><pre><code># 最强 shell 当然个人观念sudo pacman -s fish# 设置默认，建议不要默认sudo chsh -s /usr/bin/fish</code></pre><h3 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h3><pre><code># 个人超爱sudo pacman -S kupfer# 另外推荐sudo pacman -S albert</code></pre><h3 id="最好输入法"><a href="#最好输入法" class="headerlink" title="最好输入法"></a>最好输入法</h3><pre><code># 安装企鹅输入法1、Fcitx2、Fcitx 配置3、kcm-fcitxsudo pacman -S Sunpinyin# 修改配置文件,之后注销sudo vim /etc/profileexport GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=@im=fcitx# 所有地方输入中文1、打开 Fcitx 配置2、全局配置-&gt;程序-&gt;在窗口间共享状态-&gt;选择所有</code></pre><h3 id="Cisco-AnyConnect"><a href="#Cisco-AnyConnect" class="headerlink" title="Cisco AnyConnect"></a>Cisco AnyConnect</h3><pre><code>### 如果安装了 Cisco 没有问题无需操作,如果有问题请按照下面重新操作# 1、注释用户验证sudo vim vpn_install.sh # Make sure we are root# if [ `id | sed -e &#39;s/(.*//&#39;` != &quot;uid=0&quot; ]; then#   echo &quot;Sorry, you need super user privileges to run this script.&quot;#   exit 1# fi# 2、创建 rc.dsudo mkdir /etc/rc.d# 3、安装,如果还有权限 root 允许./vpn_install.sh# 4、启动服务sudo /etc/rc.d/vpnagentd start# 错误解决方案https://bbs.archlinux.org/viewtopic.php?id=190444# 以上是下载安装 yaourt 安装完美支持，Manjaro 牛逼！yaourt -S cisco-anyconnect</code></pre><h3 id="谷歌浏览器"><a href="#谷歌浏览器" class="headerlink" title="谷歌浏览器"></a>谷歌浏览器</h3><pre><code>sudo pacman -S google-chrome</code></pre><h3 id="MySQL-可视化软件"><a href="#MySQL-可视化软件" class="headerlink" title="MySQL 可视化软件"></a>MySQL 可视化软件</h3><pre><code># 还不错,就是全英文太恼火yaourt -S valentina-studio# 不太喜欢yaourt -S navicat# 完美的 Linux 下面数据库可视化工具pacman -S dbeaver</code></pre><h3 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a>QQ</h3><pre><code># 原生,就是当前版本...yaourt -s linuxqq# deepin 打包的 MIT yaourt -S deepin-wine-tim</code></pre><h3 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h3><pre><code># 安装网易云官方，无法输入中文，请自行百度，19.0.2 暂时未解决sudo pacman -S netease-cloud-music# 这个第三方的也挺不错第三方yaourt -S iease-music</code></pre><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><pre><code># 如果安装 Hexo 使用了 我这么里就不说了，在我 扬帆启航 里面有一个链接里面有详细安装 Hexo 的教程在重新装完系统之后，前面部署过的 Hexo 可以继续的使用，只需要安装 Hexo 和删除 Hexo 下面的 .deploy_git/即可重新的 Push 到 github 上面！ # 安装 hexonpm install -g hexo-cli # 附上纤细安装 Hexo 文章https://godweiyang.com/2018/04/13/hexo-blog/https://github.com/blinkfox/hexo-theme-matery</code></pre><h3 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h3><pre><code># 深度终端，说实话 deepin 这个终端真心赞sudo pamcan -S deepin-terminal# 深度看图sudo pacman -S deepin-image-viewer# 深度截图sudo pacman -S deepin-screenshot</code></pre><h3 id="Teamviewer"><a href="#Teamviewer" class="headerlink" title="Teamviewer"></a>Teamviewer</h3><pre><code># 安装sudo pacman -S teamviewer# 启动服务systemctl start teamviewerd</code></pre><h3 id="百度网盘"><a href="#百度网盘" class="headerlink" title="百度网盘"></a>百度网盘</h3><pre><code># 百度官方 Linux 版本sudo pacman -S baidunetdisk-bin</code></pre><h3 id="更新系统后乱码"><a href="#更新系统后乱码" class="headerlink" title="更新系统后乱码"></a>更新系统后乱码</h3><pre><code># 18.10 之前更新系统之后出现乱码问题，缺少中文字体，但是比系统原来字体差许多sudo pacman -S wqy-microhei# 18.10 完成支持本地化！19.0.2 完美！！</code></pre><h3 id="Docky"><a href="#Docky" class="headerlink" title="Docky"></a>Docky</h3><pre><code># 想比较下他比 plank 吃内存一些，但是也不太影响，毕竟 plank 太过于简洁了！外貌协会不摆了！sudo pacman -S latte-dock</code></pre><h3 id="搜狗输入法"><a href="#搜狗输入法" class="headerlink" title="搜狗输入法"></a>搜狗输入法</h3><p>时隔差不多 2 年，搜狗更新了！</p><pre><code>1.打开 ”添加/删除软件“2.搜索Sogou3.安装fcitx-sogoupinyin4.安装fcitx-configtool5.安装fcitx-qt46.配置~/.xprofile    export GTK_IM_MODULE=fcitx    export QT_IM_MODULE=fcitx    export XMODIFIERS=@im=fcitx# 如果搜狗输入法不能输入中文检查一下是否有中文语言包，不建议安装搜狗输入法 太老了！而且 18 以后基本安装都有问题，不建议使用</code></pre><h3 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h3><pre><code>腾讯视频都出 Linux 版本，期待微信呀# 这是 deepin yaourt -S deepin-wine-wechat# 网页打包版本yaourt -S electronic-wechat</code></pre><h3 id="Shutter"><a href="#Shutter" class="headerlink" title="Shutter"></a>Shutter</h3><pre><code># Linux 下面最好的截图软件sudo pacman -S Shutter</code></pre><h3 id="Oss"><a href="#Oss" class="headerlink" title="Oss"></a>Oss</h3><pre><code># 1、下载curl https://oss-attachment.cn-hangzhou.oss.aliyun-inc.com/oss-browser/1.9.5/oss-browser-linux-x64.zip# 2、解压unzip oss-browser-linux-x64# 3、运行oss-browser</code></pre><h3 id="亿图思维导图"><a href="#亿图思维导图" class="headerlink" title="亿图思维导图"></a>亿图思维导图</h3><pre><code>yaourt -s mindmaster</code></pre><h3 id="微信开发工具"><a href="#微信开发工具" class="headerlink" title="微信开发工具"></a>微信开发工具</h3><pre><code>sudo pacman -S wechat-devtools</code></pre><h3 id="钉钉"><a href="#钉钉" class="headerlink" title="钉钉"></a>钉钉</h3><pre><code>yaourt -S dingtalk-electron</code></pre><h3 id="blender"><a href="#blender" class="headerlink" title="blender"></a>blender</h3><pre><code># 免费开源视频剪辑工具sudo pacman -S blender</code></pre><h3 id="Phpstorm"><a href="#Phpstorm" class="headerlink" title="Phpstorm"></a>Phpstorm</h3><pre><code>yaourt -S phpstorm</code></pre><h3 id="Zeal"><a href="#Zeal" class="headerlink" title="Zeal"></a>Zeal</h3><pre><code># Linux 下面最好的离线文档，可以配合这 Phpstrom 使用pacman -S zeal# 安装好之后 Phpstrom 插件当中安装 dash 按住 ctrl+shift+d 即可调出文档</code></pre><h3 id="Redis-可视化工具"><a href="#Redis-可视化工具" class="headerlink" title="Redis 可视化工具"></a>Redis 可视化工具</h3><pre><code># 个人喜爱yaourt -S redis-desktop-manager# 另外推荐yaourt -S another-redis-desktop-manager</code></pre><h3 id="Vs-Code"><a href="#Vs-Code" class="headerlink" title="Vs Code"></a>Vs Code</h3><pre><code>pacman -S visual-studio-code-bin</code></pre><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><pre><code>yaourt -S typora</code></pre><h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h3><pre><code>yaourt -S postman</code></pre><h3 id="Goland"><a href="#Goland" class="headerlink" title="Goland"></a>Goland</h3><pre><code>sudo pacman -S goland</code></pre><h3 id="福昕"><a href="#福昕" class="headerlink" title="福昕"></a>福昕</h3><pre><code>sudo pacman -S foxitreader</code></pre><blockquote><p>好的推荐，请留言告知！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扬帆启航</title>
      <link href="/2019/08/01/%E5%A4%9A%E5%A4%9A%E5%85%B3%E7%85%A7/"/>
      <url>/2019/08/01/%E5%A4%9A%E5%A4%9A%E5%85%B3%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>在无意间查询一篇资料的时候进入到了[韦阳]的博客，第一眼就被他博客的 UI 界面吸引了，让我看起来觉得很舒服很爽！！！啊…爽！！！我本身也是比较喜欢写博文，不！我还没达不到自我写博文的时候，应该说我本身也比较喜欢记录学习。以前用过博客园、看云，但是总体上来说感觉都属于 “集中” 虽然可以自我美化，但是都没我第一眼看到[韦阳]博客的那种喜欢感觉。喜欢就走起，了解下来发现是基于 Github + Hexo 。耗时 2 天，终于搭建好个性化完成了，不容易啊！</p><p>在[韦阳]的博客首页推荐文章当中就有博客搭建的详细教程。</p><blockquote><p><a href="https://godweiyang.com/2018/04/13/hexo-blog/" target="_blank" rel="noopener">https://godweiyang.com/2018/04/13/hexo-blog/</a></p></blockquote><p>扬帆、启航</p><p><img src="https://i.loli.net/2019/09/03/RWBTwtkD2MjPavh.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 启航 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 启航 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
